{
  "version": 3,
  "sources": ["../../../../../../../../node_modules/.pnpm/@barvynkoa+particle-emitter@0.0.1_pixi.js@8.8.1/node_modules/@barvynkoa/particle-emitter/lib/particle-emitter.es.js"],
  "sourcesContent": ["/*!\n * @barvynkoa/particle-emitter - v6.0.0\n * Compiled Mon, 27 May 2024 12:15:21 UTC\n *\n * @barvynkoa/particle-emitter is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Texture, Point, Sprite, Ticker } from 'pixi.js';\n\n/**\n * A spawn shape that picks a random position along a series of line segments. If those\n * line segments form a polygon, particles will only be placed on the perimeter of that polygon.\n *\n * Example config:\n * ```javascript\n * {\n *      type: 'polygonalChain',\n *      data: [\n *          [{x: 0, y: 0}, {x: 10, y: 10}, {x: 20, y: 0}],\n *          [{x: 0, y, -10}, {x: 10, y: 0}, {x: 20, y: -10}]\n *      ]\n * }\n * ```\n */\nclass PolygonalChain {\n    /**\n     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\n     */\n    constructor(data) {\n        this.segments = [];\n        this.countingLengths = [];\n        this.totalLength = 0;\n        this.init(data);\n    }\n    /**\n     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\n     */\n    init(data) {\n        // if data is not present, set up a segment of length 0\n        if (!data || !data.length) {\n            this.segments.push({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 }, l: 0 });\n        }\n        else if (Array.isArray(data[0])) {\n            // list of segment chains, each defined as a list of points\n            for (let i = 0; i < data.length; ++i) {\n                // loop through the chain, connecting points\n                const chain = data[i];\n                let prevPoint = chain[0];\n                for (let j = 1; j < chain.length; ++j) {\n                    const second = chain[j];\n                    this.segments.push({ p1: prevPoint, p2: second, l: 0 });\n                    prevPoint = second;\n                }\n            }\n        }\n        else {\n            let prevPoint = data[0];\n            // list of points\n            for (let i = 1; i < data.length; ++i) {\n                const second = data[i];\n                this.segments.push({ p1: prevPoint, p2: second, l: 0 });\n                prevPoint = second;\n            }\n        }\n        // now go through our segments to calculate the lengths so that we\n        // can set up a nice weighted random distribution\n        for (let i = 0; i < this.segments.length; ++i) {\n            const { p1, p2 } = this.segments[i];\n            const segLength = Math.sqrt(((p2.x - p1.x) * (p2.x - p1.x)) + ((p2.y - p1.y) * (p2.y - p1.y)));\n            // save length so we can turn a random number into a 0-1 interpolation value later\n            this.segments[i].l = segLength;\n            this.totalLength += segLength;\n            // keep track of the length so far, counting up\n            this.countingLengths.push(this.totalLength);\n        }\n    }\n    /**\n     * Gets a random point in the chain.\n     * @param out - Particle ?, because was point data\n     */\n    getRandPos(out) {\n        // select a random spot in the length of the chain\n        const rand = Math.random() * this.totalLength;\n        let chosenSeg;\n        let lerp;\n        // if only one segment, it wins\n        if (this.segments.length === 1) {\n            chosenSeg = this.segments[0];\n            lerp = rand;\n        }\n        else {\n            // otherwise, go through countingLengths until we have determined\n            // which segment we chose\n            for (let i = 0; i < this.countingLengths.length; ++i) {\n                if (rand < this.countingLengths[i]) {\n                    chosenSeg = this.segments[i];\n                    // set lerp equal to the length into that segment\n                    // (i.e. the remainder after subtracting all the segments before it)\n                    lerp = i === 0 ? rand : rand - this.countingLengths[i - 1];\n                    break;\n                }\n            }\n        }\n        // divide lerp by the segment length, to result in a 0-1 number.\n        lerp /= chosenSeg.l || 1;\n        const { p1, p2 } = chosenSeg;\n        // now calculate the position in the segment that the lerp value represents\n        out.x = p1.x + (lerp * (p2.x - p1.x));\n        out.y = p1.y + (lerp * (p2.y - p1.y));\n    }\n}\nPolygonalChain.type = 'polygonalChain';\nPolygonalChain.editorConfig = null;\n\n/**\n * A SpawnShape that randomly picks locations inside a rectangle.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'rect',\n *     data: {\n *          x: 0,\n *          y: 0,\n *          w: 10,\n *          h: 100\n *     }\n * }\n * ```\n */\nclass Rectangle {\n    constructor(config) {\n        this.x = config.x;\n        this.y = config.y;\n        this.w = config.w;\n        this.h = config.h;\n    }\n    getRandPos(particle) {\n        // place the particle at a random point in the rectangle\n        particle.x = (Math.random() * this.w) + this.x;\n        particle.y = (Math.random() * this.h) + this.y;\n    }\n}\nRectangle.type = 'rect';\nRectangle.editorConfig = null;\n\n/**\n * A single node in a PropertyList.\n */\nclass PropertyNode {\n    /**\n     * @param value The value for this node\n     * @param time The time for this node, between 0-1\n     * @param [ease] Custom ease for this list. Only relevant for the first node.\n     */\n    constructor(value, time, ease) {\n        this.value = value;\n        this.time = time;\n        this.next = null;\n        this.isStepped = false;\n        if (ease) {\n            this.ease = typeof ease === 'function' ? ease : generateEase(ease);\n        }\n        else {\n            this.ease = null;\n        }\n    }\n    /**\n     * Creates a list of property values from a data object {list, isStepped} with a list of objects in\n     * the form {value, time}. Alternatively, the data object can be in the deprecated form of\n     * {start, end}.\n     * @param data The data for the list.\n     * @param data.list The array of value and time objects.\n     * @param data.isStepped If the list is stepped rather than interpolated.\n     * @param data.ease Custom ease for this list.\n     * @return The first node in the list\n     */\n    // eslint-disable-next-line max-len\n    static createList(data) {\n        if ('list' in data) {\n            const array = data.list;\n            let node;\n            const { value, time } = array[0];\n            // eslint-disable-next-line max-len\n            const first = node = new PropertyNode(typeof value === 'string' ? hexToRGB(value) : value, time, data.ease);\n            // only set up subsequent nodes if there are a bunch or the 2nd one is different from the first\n            if (array.length > 2 || (array.length === 2 && array[1].value !== value)) {\n                for (let i = 1; i < array.length; ++i) {\n                    const { value, time } = array[i];\n                    node.next = new PropertyNode(typeof value === 'string' ? hexToRGB(value) : value, time);\n                    node = node.next;\n                }\n            }\n            first.isStepped = !!data.isStepped;\n            return first;\n        }\n        // Handle deprecated version here\n        const start = new PropertyNode(typeof data.start === 'string' ? hexToRGB(data.start) : data.start, 0);\n        // only set up a next value if it is different from the starting value\n        if (data.end !== data.start) {\n            start.next = new PropertyNode(typeof data.end === 'string' ? hexToRGB(data.end) : data.end, 1);\n        }\n        return start;\n    }\n}\n\n/**\n * The method used by behaviors to fetch textures. Defaults to Texture.from.\n */\n// get Texture.from(), only supports V5 and V6 with individual packages\n// eslint-disable-next-line prefer-const\nlet GetTextureFromString = Texture.from;\n/**\n * If errors and warnings should be logged within the library.\n */\nconst verbose = false;\nconst DEG_TO_RADS = Math.PI / 180;\n/**\n * Rotates a point by a given angle.\n * @param angle The angle to rotate by in radians\n * @param p The point to rotate around 0,0.\n */\nfunction rotatePoint(angle, p) {\n    if (!angle)\n        return;\n    const s = Math.sin(angle);\n    const c = Math.cos(angle);\n    const xnew = (p.x * c) - (p.y * s);\n    const ynew = (p.x * s) + (p.y * c);\n    p.x = xnew;\n    p.y = ynew;\n}\n/**\n * Combines separate color components (0-255) into a single uint color.\n * @param r The red value of the color\n * @param g The green value of the color\n * @param b The blue value of the color\n * @return The color in the form of 0xRRGGBB\n */\nfunction combineRGBComponents(r, g, b /* , a*/) {\n    return /* a << 24 |*/ (r << 16) | (g << 8) | b;\n}\n/**\n * Returns the length (or magnitude) of this point.\n * @param point The point to measure length\n * @return The length of this point.\n */\nfunction length(point) {\n    return Math.sqrt((point.x * point.x) + (point.y * point.y));\n}\n/**\n * Reduces the point to a length of 1.\n * @param point The point to normalize\n */\nfunction normalize(point) {\n    const oneOverLen = 1 / length(point);\n    point.x *= oneOverLen;\n    point.y *= oneOverLen;\n}\n/**\n * Multiplies the x and y values of this point by a value.\n * @param point The point to scaleBy\n * @param value The value to scale by.\n */\nfunction scaleBy(point, value) {\n    point.x *= value;\n    point.y *= value;\n}\n/**\n * Converts a hex string from \"#AARRGGBB\", \"#RRGGBB\", \"0xAARRGGBB\", \"0xRRGGBB\",\n * \"AARRGGBB\", or \"RRGGBB\" to an object of ints of 0-255, as\n * {r, g, b, (a)}.\n * @param color The input color string.\n * @param output An object to put the output in. If omitted, a new object is created.\n * @return The object with r, g, and b properties, possibly with an a property.\n */\nfunction hexToRGB(color, output) {\n    if (!output) {\n        output = {};\n    }\n    if (color.charAt(0) === '#') {\n        color = color.substr(1);\n    }\n    else if (color.indexOf('0x') === 0) {\n        color = color.substr(2);\n    }\n    let alpha;\n    if (color.length === 8) {\n        alpha = color.substr(0, 2);\n        color = color.substr(2);\n    }\n    output.r = parseInt(color.substr(0, 2), 16); // Red\n    output.g = parseInt(color.substr(2, 2), 16); // Green\n    output.b = parseInt(color.substr(4, 2), 16); // Blue\n    if (alpha) {\n        output.a = parseInt(alpha, 16);\n    }\n    return output;\n}\n/**\n * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated\n * by the related tool at http://www.greensock.com/customease/.\n * @param segments An array of segments, as created by\n * http://www.greensock.com/customease/.\n * @return A function that calculates the percentage of change at\n *                    a given point in time (0-1 inclusive).\n */\nfunction generateEase(segments) {\n    const qty = segments.length;\n    const oneOverQty = 1 / qty;\n    /*\n        * Calculates the percentage of change at a given point in time (0-1 inclusive).\n        * @param {Number} time The time of the ease, 0-1 inclusive.\n        * @return {Number} The percentage of the change, 0-1 inclusive (unless your\n        *                  ease goes outside those bounds).\n        */\n    // eslint-disable-next-line func-names\n    return function (time) {\n        const i = (qty * time) | 0; // do a quick floor operation\n        const t = (time - (i * oneOverQty)) * qty;\n        const s = segments[i] || segments[qty - 1];\n        return (s.s + (t * ((2 * (1 - t) * (s.cp - s.s)) + (t * (s.e - s.s)))));\n    };\n}\n/**\n * Gets a blend mode, ensuring that it is valid.\n * @param name The name of the blend mode to get.\n * @return The blend mode as specified in the PIXI.BLEND_MODES enumeration.\n */\nfunction getBlendMode(name) {\n    return name || 'normal';\n}\n/**\n * Converts a list of {value, time} objects starting at time 0 and ending at time 1 into an evenly\n * spaced stepped list of PropertyNodes for color values. This is primarily to handle conversion of\n * linear gradients to fewer colors, allowing for some optimization for Canvas2d fallbacks.\n * @param list The list of data to convert.\n * @param [numSteps=10] The number of steps to use.\n * @return The blend mode as specified in the PIXI.blendModes enumeration.\n */\nfunction createSteppedGradient(list, numSteps = 10) {\n    if (typeof numSteps !== 'number' || numSteps <= 0) {\n        numSteps = 10;\n    }\n    const first = new PropertyNode(hexToRGB(list[0].value), list[0].time);\n    first.isStepped = true;\n    let currentNode = first;\n    let current = list[0];\n    let nextIndex = 1;\n    let next = list[nextIndex];\n    for (let i = 1; i < numSteps; ++i) {\n        let lerp = i / numSteps;\n        // ensure we are on the right segment, if multiple\n        while (lerp > next.time) {\n            current = next;\n            next = list[++nextIndex];\n        }\n        // convert the lerp value to the segment range\n        lerp = (lerp - current.time) / (next.time - current.time);\n        const curVal = hexToRGB(current.value);\n        const nextVal = hexToRGB(next.value);\n        const output = {\n            r: ((nextVal.r - curVal.r) * lerp) + curVal.r,\n            g: ((nextVal.g - curVal.g) * lerp) + curVal.g,\n            b: ((nextVal.b - curVal.b) * lerp) + curVal.b,\n        };\n        currentNode.next = new PropertyNode(output, i / numSteps);\n        currentNode = currentNode.next;\n    }\n    // we don't need to have a PropertyNode for time of 1, because in a stepped version at that point\n    // the particle has died of old age\n    return first;\n}\n\nvar ParticleUtils = {\n    __proto__: null,\n    DEG_TO_RADS: DEG_TO_RADS,\n    GetTextureFromString: GetTextureFromString,\n    combineRGBComponents: combineRGBComponents,\n    createSteppedGradient: createSteppedGradient,\n    generateEase: generateEase,\n    getBlendMode: getBlendMode,\n    hexToRGB: hexToRGB,\n    length: length,\n    normalize: normalize,\n    rotatePoint: rotatePoint,\n    scaleBy: scaleBy,\n    verbose: verbose\n};\n\n/**\n * A class for spawning particles in a circle or ring.\n * Can optionally apply rotation to particles so that they are aimed away from the center of the circle.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'torus',\n *     data: {\n *          radius: 30,\n *          x: 0,\n *          y: 0,\n *          innerRadius: 10,\n *          rotation: true\n *     }\n * }\n * ```\n */\nclass Torus {\n    constructor(config) {\n        this.x = config.x || 0;\n        this.y = config.y || 0;\n        this.radius = config.radius;\n        this.innerRadius = config.innerRadius || 0;\n        this.rotation = !!config.affectRotation;\n    }\n    getRandPos(particle) {\n        // place the particle at a random radius in the ring\n        if (this.innerRadius !== this.radius) {\n            particle.x = (Math.random() * (this.radius - this.innerRadius)) + this.innerRadius;\n        }\n        else {\n            particle.x = this.radius;\n        }\n        particle.y = 0;\n        // rotate the point to a random angle in the circle\n        const angle = Math.random() * Math.PI * 2;\n        if (this.rotation) {\n            particle.rotation += angle;\n        }\n        rotatePoint(angle, particle.position);\n        // now add in the center of the torus\n        particle.position.x += this.x;\n        particle.position.y += this.y;\n    }\n}\nTorus.type = 'torus';\nTorus.editorConfig = null;\n\n/**\n * Standard behavior order values, specifying when/how they are used. Other numeric values can be used,\n * but only the Spawn value will be handled in a special way. All other values will be sorted numerically.\n * Behaviors with the same value will not be given any specific sort order, as they are assumed to not\n * interfere with each other.\n */\nvar BehaviorOrder;\n(function (BehaviorOrder) {\n    /**\n     * Spawn - initial placement and/or rotation. This happens before rotation/translation due to\n     * emitter rotation/position is applied.\n     */\n    BehaviorOrder[BehaviorOrder[\"Spawn\"] = 0] = \"Spawn\";\n    /**\n     * Normal priority, for things that don't matter when they are applied.\n     */\n    BehaviorOrder[BehaviorOrder[\"Normal\"] = 2] = \"Normal\";\n    /**\n     * Delayed priority, for things that need to read other values in order to act correctly.\n     */\n    BehaviorOrder[BehaviorOrder[\"Late\"] = 5] = \"Late\";\n})(BehaviorOrder || (BehaviorOrder = {}));\n\n/**\n * A Movement behavior that handles movement by applying a constant acceleration to all particles.\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"moveAcceleration\",\n *     \"config\": {\n *          \"accel\": {\n *               \"x\": 0,\n *               \"y\": 2000\n *          },\n *          \"minStart\": 600,\n *          \"maxStart\": 600,\n *          \"rotate\": true\n *     }\n *}\n * ```\n */\nclass AccelerationBehavior {\n    constructor(config) {\n        // doesn't _really_ need to be late, but doing so ensures that we can override any\n        // rotation behavior that is mistakenly added\n        this.order = BehaviorOrder.Late;\n        this.minStart = config.minStart;\n        this.maxStart = config.maxStart;\n        this.accel = config.accel;\n        this.rotate = !!config.rotate;\n        this.maxSpeed = config.maxSpeed ?? 0;\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            const speed = (Math.random() * (this.maxStart - this.minStart)) + this.minStart;\n            if (!next.config.velocity) {\n                next.config.velocity = new Point(speed, 0);\n            }\n            else {\n                next.config.velocity.set(speed, 0);\n            }\n            rotatePoint(next.rotation, next.config.velocity);\n            next = next.next;\n        }\n    }\n    updateParticle(particle, deltaSec) {\n        const vel = particle.config.velocity;\n        const oldVX = vel.x;\n        const oldVY = vel.y;\n        vel.x += this.accel.x * deltaSec;\n        vel.y += this.accel.y * deltaSec;\n        if (this.maxSpeed) {\n            const currentSpeed = length(vel);\n            // if we are going faster than we should, clamp at the max speed\n            // DO NOT recalculate vector length\n            if (currentSpeed > this.maxSpeed) {\n                scaleBy(vel, this.maxSpeed / currentSpeed);\n            }\n        }\n        // calculate position delta by the midpoint between our old velocity and our new velocity\n        particle.x += (oldVX + vel.x) / 2 * deltaSec;\n        particle.y += (oldVY + vel.y) / 2 * deltaSec;\n        if (this.rotate) {\n            particle.rotation = Math.atan2(vel.y, vel.x);\n        }\n    }\n}\nAccelerationBehavior.type = 'moveAcceleration';\nAccelerationBehavior.editorConfig = null;\n\nfunction intValueSimple(lerp) {\n    if (this.ease)\n        lerp = this.ease(lerp);\n    return ((this.first.next.value - this.first.value) * lerp) + this.first.value;\n}\nfunction intColorSimple(lerp) {\n    if (this.ease)\n        lerp = this.ease(lerp);\n    const curVal = this.first.value;\n    const nextVal = this.first.next.value;\n    const r = ((nextVal.r - curVal.r) * lerp) + curVal.r;\n    const g = ((nextVal.g - curVal.g) * lerp) + curVal.g;\n    const b = ((nextVal.b - curVal.b) * lerp) + curVal.b;\n    return combineRGBComponents(r, g, b);\n}\nfunction intValueComplex(lerp) {\n    if (this.ease)\n        lerp = this.ease(lerp);\n    // make sure we are on the right segment\n    let current = this.first;\n    let next = current.next;\n    while (lerp > next.time) {\n        current = next;\n        next = next.next;\n    }\n    // convert the lerp value to the segment range\n    lerp = (lerp - current.time) / (next.time - current.time);\n    return ((next.value - current.value) * lerp) + current.value;\n}\nfunction intColorComplex(lerp) {\n    if (this.ease)\n        lerp = this.ease(lerp);\n    // make sure we are on the right segment\n    let current = this.first;\n    let next = current.next;\n    while (lerp > next.time) {\n        current = next;\n        next = next.next;\n    }\n    // convert the lerp value to the segment range\n    lerp = (lerp - current.time) / (next.time - current.time);\n    const curVal = current.value;\n    const nextVal = next.value;\n    const r = ((nextVal.r - curVal.r) * lerp) + curVal.r;\n    const g = ((nextVal.g - curVal.g) * lerp) + curVal.g;\n    const b = ((nextVal.b - curVal.b) * lerp) + curVal.b;\n    return combineRGBComponents(r, g, b);\n}\nfunction intValueStepped(lerp) {\n    if (this.ease)\n        lerp = this.ease(lerp);\n    // make sure we are on the right segment\n    let current = this.first;\n    while (current.next && lerp > current.next.time) {\n        current = current.next;\n    }\n    return current.value;\n}\nfunction intColorStepped(lerp) {\n    if (this.ease)\n        lerp = this.ease(lerp);\n    // make sure we are on the right segment\n    let current = this.first;\n    while (current.next && lerp > current.next.time) {\n        current = current.next;\n    }\n    const curVal = current.value;\n    return combineRGBComponents(curVal.r, curVal.g, curVal.b);\n}\n/**\n * Singly linked list container for keeping track of interpolated properties for particles.\n * Each Particle will have one of these for each interpolated property.\n */\nclass PropertyList {\n    /**\n     * @param isColor If this list handles color values\n     */\n    constructor(isColor = false) {\n        this.first = null;\n        this.isColor = !!isColor;\n        this.interpolate = null;\n        this.ease = null;\n    }\n    /**\n     * Resets the list for use.\n     * @param first The first node in the list.\n     * @param first.isStepped If the values should be stepped instead of interpolated linearly.\n     */\n    reset(first) {\n        this.first = first;\n        const isSimple = first.next && first.next.time >= 1;\n        if (isSimple) {\n            this.interpolate = this.isColor ? intColorSimple : intValueSimple;\n        }\n        else if (first.isStepped) {\n            this.interpolate = this.isColor ? intColorStepped : intValueStepped;\n        }\n        else {\n            this.interpolate = this.isColor ? intColorComplex : intValueComplex;\n        }\n        this.ease = this.first.ease;\n    }\n}\n\n/**\n * An Alpha behavior that applies an interpolated or stepped list of values to the particle's opacity.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'alpha',\n *     config: {\n *         alpha: {\n *              list: [{value: 0, time: 0}, {value: 1, time: 0.25}, {value: 0, time: 1}]\n *         },\n *     }\n * }\n * ```\n */\nclass AlphaBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.alpha));\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            next.alpha = this.list.first.value;\n            next = next.next;\n        }\n    }\n    updateParticle(particle) {\n        particle.alpha = this.list.interpolate(particle.agePercent);\n    }\n}\nAlphaBehavior.type = 'alpha';\nAlphaBehavior.editorConfig = null;\n/**\n * An Alpha behavior that applies a static value to the particle's opacity at particle initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'alphaStatic',\n *     config: {\n *         alpha: 0.75,\n *     }\n * }\n * ```\n */\nclass StaticAlphaBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        this.value = config.alpha;\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            next.alpha = this.value;\n            next = next.next;\n        }\n    }\n}\nStaticAlphaBehavior.type = 'alphaStatic';\nStaticAlphaBehavior.editorConfig = null;\n\nfunction getTextures(textures) {\n    const outTextures = [];\n    for (let j = 0; j < textures.length; ++j) {\n        let tex = textures[j];\n        if (typeof tex === 'string') {\n            outTextures.push(GetTextureFromString(tex));\n        }\n        else if (tex instanceof Texture) {\n            outTextures.push(tex);\n        }\n        // assume an object with extra data determining duplicate frame data\n        else {\n            let dupe = tex.count || 1;\n            if (typeof tex.texture === 'string') {\n                tex = GetTextureFromString(tex.texture);\n            }\n            else // if(tex.texture instanceof Texture)\n             {\n                tex = tex.texture;\n            }\n            for (; dupe > 0; --dupe) {\n                outTextures.push(tex);\n            }\n        }\n    }\n    return outTextures;\n}\n/**\n * A Texture behavior that picks a random animation for each particle to play.\n * See {@link AnimatedParticleArt} for detailed configuration info.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'animatedRandom',\n *     config: {\n *         anims: [\n *              {\n *                  framerate: 25,\n *                  loop: true,\n *                  textures: ['frame1', 'frame2', 'frame3']\n *              },\n *              {\n *                  framerate: 25,\n *                  loop: true,\n *                  textures: ['frame3', 'frame2', 'frame1']\n *              }\n *         ],\n *     }\n * }\n * ```\n */\nclass RandomAnimatedTextureBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        this.anims = [];\n        for (let i = 0; i < config.anims.length; ++i) {\n            const anim = config.anims[i];\n            const textures = getTextures(anim.textures);\n            // eslint-disable-next-line no-nested-ternary\n            const framerate = anim.framerate < 0 ? -1 : (anim.framerate > 0 ? anim.framerate : 60);\n            const parsedAnim = {\n                textures,\n                duration: framerate > 0 ? textures.length / framerate : 0,\n                framerate,\n                loop: framerate > 0 ? !!anim.loop : false,\n            };\n            this.anims.push(parsedAnim);\n        }\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            const index = Math.floor(Math.random() * this.anims.length);\n            const anim = next.config.anim = this.anims[index];\n            next.texture = anim.textures[0];\n            next.config.animElapsed = 0;\n            // if anim should match particle life exactly\n            if (anim.framerate === -1) {\n                next.config.animDuration = next.maxLife;\n                next.config.animFramerate = anim.textures.length / next.maxLife;\n            }\n            else {\n                next.config.animDuration = anim.duration;\n                next.config.animFramerate = anim.framerate;\n            }\n            next = next.next;\n        }\n    }\n    updateParticle(particle, deltaSec) {\n        const config = particle.config;\n        const anim = config.anim;\n        config.animElapsed += deltaSec;\n        if (config.animElapsed >= config.animDuration) {\n            // loop elapsed back around\n            if (config.anim.loop) {\n                config.animElapsed = config.animElapsed % config.animDuration;\n            }\n            // subtract a small amount to prevent attempting to go past the end of the animation\n            else {\n                config.animElapsed = config.animDuration - 0.000001;\n            }\n        }\n        // add a very small number to the frame and then floor it to avoid\n        // the frame being one short due to floating point errors.\n        const frame = ((config.animElapsed * config.animFramerate) + 0.0000001) | 0;\n        // in the very rare case that framerate * elapsed math ends up going past the end, use the last texture\n        particle.texture = anim.textures[frame] || anim.textures[anim.textures.length - 1] || Texture.EMPTY;\n    }\n}\nRandomAnimatedTextureBehavior.type = 'animatedRandom';\nRandomAnimatedTextureBehavior.editorConfig = null;\n/**\n * A Texture behavior that uses a single animation for each particle to play.\n * See {@link AnimatedParticleArt} for detailed configuration info.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'animatedSingle',\n *     config: {\n *         anim: {\n *              framerate: 25,\n *              loop: true,\n *              textures: ['frame1', 'frame2', 'frame3']\n *         }\n *     }\n * }\n * ```\n */\nclass SingleAnimatedTextureBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        const anim = config.anim;\n        const textures = getTextures(anim.textures);\n        // eslint-disable-next-line no-nested-ternary\n        const framerate = anim.framerate < 0 ? -1 : (anim.framerate > 0 ? anim.framerate : 60);\n        this.anim = {\n            textures,\n            duration: framerate > 0 ? textures.length / framerate : 0,\n            framerate,\n            loop: framerate > 0 ? !!anim.loop : false,\n        };\n    }\n    initParticles(first) {\n        let next = first;\n        const anim = this.anim;\n        while (next) {\n            next.texture = anim.textures[0];\n            next.config.animElapsed = 0;\n            // if anim should match particle life exactly\n            if (anim.framerate === -1) {\n                next.config.animDuration = next.maxLife;\n                next.config.animFramerate = anim.textures.length / next.maxLife;\n            }\n            else {\n                next.config.animDuration = anim.duration;\n                next.config.animFramerate = anim.framerate;\n            }\n            next = next.next;\n        }\n    }\n    updateParticle(particle, deltaSec) {\n        const anim = this.anim;\n        const config = particle.config;\n        config.animElapsed += deltaSec;\n        if (config.animElapsed >= config.animDuration) {\n            // loop elapsed back around\n            if (anim.loop) {\n                config.animElapsed = config.animElapsed % config.animDuration;\n            }\n            // subtract a small amount to prevent attempting to go past the end of the animation\n            else {\n                config.animElapsed = config.animDuration - 0.000001;\n            }\n        }\n        // add a very small number to the frame and then floor it to avoid\n        // the frame being one short due to floating point errors.\n        const frame = ((config.animElapsed * config.animFramerate) + 0.0000001) | 0;\n        // in the very rare case that framerate * elapsed math ends up going past the end, use the last texture\n        particle.texture = anim.textures[frame] || anim.textures[anim.textures.length - 1] || Texture.EMPTY;\n    }\n}\nSingleAnimatedTextureBehavior.type = 'animatedSingle';\nSingleAnimatedTextureBehavior.editorConfig = null;\n\n/**\n * A Blend Mode behavior that applies a blend mode value to the particle at initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'blendMode',\n *     config: {\n *         blendMode: 'multiply',\n *     }\n * }\n * ```\n */\nclass BlendModeBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        this.value = config.blendMode;\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            next.blendMode = getBlendMode(this.value);\n            next = next.next;\n        }\n    }\n}\nBlendModeBehavior.type = 'blendMode';\nBlendModeBehavior.editorConfig = null;\n\n/**\n * A Spawn behavior that sends particles out from a single point or ring, and is capable of evenly spacing\n * the particle's starting angles.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'spawnBurst',\n *     config: {\n *          spacing: 90,\n *          start: 0,\n *          distance: 40,\n *     }\n * }\n * ```\n */\nclass BurstSpawnBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Spawn;\n        this.spacing = config.spacing * DEG_TO_RADS;\n        this.start = config.start * DEG_TO_RADS;\n        this.distance = config.distance;\n    }\n    initParticles(first) {\n        let count = 0;\n        let next = first;\n        while (next) {\n            let angle;\n            if (this.spacing) {\n                angle = this.start + (this.spacing * count);\n            }\n            else {\n                angle = Math.random() * Math.PI * 2;\n            }\n            next.rotation = angle;\n            if (this.distance) {\n                next.position.x = this.distance;\n                rotatePoint(angle, next.position);\n            }\n            next = next.next;\n            ++count;\n        }\n    }\n}\nBurstSpawnBehavior.type = 'spawnBurst';\nBurstSpawnBehavior.editorConfig = null;\n\n/**\n * A Color behavior that applies an interpolated or stepped list of values to the particle's tint property.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'color',\n *     config: {\n *         color: {\n *              list: [{value: '#ff0000' time: 0}, {value: '#00ff00', time: 0.5}, {value: '#0000ff', time: 1}]\n *         },\n *     }\n * }\n * ```\n */\nclass ColorBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        this.list = new PropertyList(true);\n        this.list.reset(PropertyNode.createList(config.color));\n    }\n    initParticles(first) {\n        let next = first;\n        const color = this.list.first.value;\n        const tint = combineRGBComponents(color.r, color.g, color.b);\n        while (next) {\n            next.tint = tint;\n            next = next.next;\n        }\n    }\n    updateParticle(particle) {\n        particle.tint = this.list.interpolate(particle.agePercent);\n    }\n}\nColorBehavior.type = 'color';\nColorBehavior.editorConfig = null;\n/**\n * A Color behavior that applies a single color to the particle's tint property at initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'colorStatic',\n *     config: {\n *         color: '#ffff00',\n *     }\n * }\n * ```\n */\nclass StaticColorBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        let color = config.color;\n        if (color.charAt(0) === '#') {\n            color = color.substr(1);\n        }\n        else if (color.indexOf('0x') === 0) {\n            color = color.substr(2);\n        }\n        this.value = parseInt(color, 16);\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            next.tint = this.value;\n            next = next.next;\n        }\n    }\n}\nStaticColorBehavior.type = 'colorStatic';\nStaticColorBehavior.editorConfig = null;\n\n/**\n * A Texture behavior that assigns a texture to each particle from its list, in order, before looping around to the first\n * texture again. String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'textureOrdered',\n *     config: {\n *         textures: [\"myTex1Id\", \"myTex2Id\", \"myTex3Id\", \"myTex4Id\"],\n *     }\n * }\n * ```\n */\nclass OrderedTextureBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        this.index = 0;\n        this.textures = config.textures.map((tex) => (typeof tex === 'string' ? GetTextureFromString(tex) : tex));\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            next.texture = this.textures[this.index];\n            if (++this.index >= this.textures.length) {\n                this.index = 0;\n            }\n            next = next.next;\n        }\n    }\n}\nOrderedTextureBehavior.type = 'textureOrdered';\nOrderedTextureBehavior.editorConfig = null;\n\n/**\n * A helper point for math things.\n * @hidden\n */\nconst helperPoint = new Point();\n/**\n * A hand picked list of Math functions (and a couple properties) that are\n * allowable. They should be used without the preceding \"Math.\"\n * @hidden\n */\nconst MATH_FUNCS = [\n    'E',\n    'LN2',\n    'LN10',\n    'LOG2E',\n    'LOG10E',\n    'PI',\n    'SQRT1_2',\n    'SQRT2',\n    'abs',\n    'acos',\n    'acosh',\n    'asin',\n    'asinh',\n    'atan',\n    'atanh',\n    'atan2',\n    'cbrt',\n    'ceil',\n    'cos',\n    'cosh',\n    'exp',\n    'expm1',\n    'floor',\n    'fround',\n    'hypot',\n    'log',\n    'log1p',\n    'log10',\n    'log2',\n    'max',\n    'min',\n    'pow',\n    'random',\n    'round',\n    'sign',\n    'sin',\n    'sinh',\n    'sqrt',\n    'tan',\n    'tanh',\n];\n/**\n * create an actual regular expression object from the string\n * @hidden\n */\nconst WHITELISTER = new RegExp([\n    // Allow the 4 basic operations, parentheses and all numbers/decimals, as well\n    // as 'x', for the variable usage.\n    '[01234567890\\\\.\\\\*\\\\-\\\\+\\\\/\\\\(\\\\)x ,]',\n].concat(MATH_FUNCS).join('|'), 'g');\n/**\n * Parses a string into a function for path following.\n * This involves whitelisting the string for safety, inserting \"Math.\" to math function\n * names, and using `new Function()` to generate a function.\n * @hidden\n * @param pathString The string to parse.\n * @return The path function - takes x, outputs y.\n */\nfunction parsePath(pathString) {\n    const matches = pathString.match(WHITELISTER);\n    for (let i = matches.length - 1; i >= 0; --i) {\n        if (MATH_FUNCS.indexOf(matches[i]) >= 0) {\n            matches[i] = `Math.${matches[i]}`;\n        }\n    }\n    pathString = matches.join('');\n    // eslint-disable-next-line no-new-func\n    return new Function('x', `return ${pathString};`);\n}\n/**\n * A particle that follows a path defined by an algebraic expression, e.g. \"sin(x)\" or\n * \"5x + 3\".\n * To use this class, the behavior config must have a \"path\" string or function.\n *\n * A string should have \"x\" in it to represent movement (from the\n * speed settings of the behavior). It may have numbers, parentheses, the four basic\n * operations, and any Math functions or properties (without the preceding \"Math.\").\n * The overall movement of the particle and the expression value become x and y positions for\n * the particle, respectively. The final position is rotated by the spawn rotation/angle of\n * the particle.\n *\n * A function merely needs to accept the \"x\" argument and output the a corresponding \"y\" value.\n *\n * Some example paths:\n *\n * * `\"sin(x/10) * 20\"` A sine wave path.\n * * `\"cos(x/100) * 30\"` Particles curve counterclockwise (for medium speed/low lifetime particles)\n * * `\"pow(x/10, 2) / 2\"` Particles curve clockwise (remember, +y is down).\n * * `(x) => Math.floor(x) * 3` Supplying an existing function should look like this\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"movePath\",\n *     \"config\": {\n *          \"path\": \"round(sin(x) * 2\",\n *          \"speed\": {\n *              \"list\": [{value: 10, time: 0}, {value: 100, time: 0.25}, {value: 0, time: 1}],\n *          },\n *          \"minMult\": 0.8\n *     }\n *}\n */\nclass PathBehavior {\n    constructor(config) {\n        // *MUST* happen after other behaviors do initialization so that we can read initial transformations\n        this.order = BehaviorOrder.Late;\n        if (config.path) {\n            if (typeof config.path === 'function') {\n                this.path = config.path;\n            }\n            else {\n                try {\n                    this.path = parsePath(config.path);\n                }\n                catch (e) {\n                    this.path = null;\n                }\n            }\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n            this.path = (x) => x;\n        }\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.speed));\n        this.minMult = config.minMult ?? 1;\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            /*\n             * The initial rotation in degrees of the particle, because the direction of the path\n             * is based on that.\n             */\n            next.config.initRotation = next.rotation;\n            /* The initial position of the particle, as all path movement is added to that. */\n            if (!next.config.initPosition) {\n                next.config.initPosition = new Point(next.x, next.y);\n            }\n            else {\n                next.config.initPosition.copyFrom(next.position);\n            }\n            /* Total single directional movement, due to speed. */\n            next.config.movement = 0;\n            // also do speed multiplier, since this includes basic speed movement\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n            next.config.speedMult = mult;\n            next = next.next;\n        }\n    }\n    updateParticle(particle, deltaSec) {\n        // increase linear movement based on speed\n        const speed = this.list.interpolate(particle.agePercent) * particle.config.speedMult;\n        particle.config.movement += speed * deltaSec;\n        // set up the helper point for rotation\n        helperPoint.x = particle.config.movement;\n        helperPoint.y = this.path(helperPoint.x);\n        rotatePoint(particle.config.initRotation, helperPoint);\n        particle.position.x = particle.config.initPosition.x + helperPoint.x;\n        particle.position.y = particle.config.initPosition.y + helperPoint.y;\n    }\n}\nPathBehavior.type = 'movePath';\nPathBehavior.editorConfig = null;\n\n/**\n * A Spawn behavior that sends particles out from a single point at the emitter's position.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'spawnPoint',\n *     config: {}\n * }\n * ```\n */\nclass PointSpawnBehavior {\n    constructor() {\n        this.order = BehaviorOrder.Spawn;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    initParticles(_first) {\n        // really just a no-op\n    }\n}\nPointSpawnBehavior.type = 'spawnPoint';\nPointSpawnBehavior.editorConfig = null;\n\n/**\n * A Texture behavior that assigns a random texture to each particle from its list.\n * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'textureRandom',\n *     config: {\n *         textures: [\"myTex1Id\", \"myTex2Id\", \"myTex3Id\", \"myTex4Id\"],\n *     }\n * }\n * ```\n */\nclass RandomTextureBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        this.textures = config.textures.map((tex) => (typeof tex === 'string' ? GetTextureFromString(tex) : tex));\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            const index = Math.floor(Math.random() * this.textures.length);\n            next.texture = this.textures[index];\n            next = next.next;\n        }\n    }\n}\nRandomTextureBehavior.type = 'textureRandom';\nRandomTextureBehavior.editorConfig = null;\n\n/**\n * A Rotation behavior that handles starting rotation, rotation speed, and rotational acceleration.\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"rotation\",\n *     \"config\": {\n *          \"minStart\": 0,\n *          \"maxStart\": 180,\n *          \"minSpeed\": 30,\n *          \"maxSpeed\": 45,\n *          \"accel\": 20\n *     }\n *}\n * ```\n */\nclass RotationBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        this.minStart = config.minStart * DEG_TO_RADS;\n        this.maxStart = config.maxStart * DEG_TO_RADS;\n        this.minSpeed = config.minSpeed * DEG_TO_RADS;\n        this.maxSpeed = config.maxSpeed * DEG_TO_RADS;\n        this.accel = config.accel * DEG_TO_RADS;\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            if (this.minStart === this.maxStart) {\n                next.rotation += this.maxStart;\n            }\n            else {\n                next.rotation += (Math.random() * (this.maxStart - this.minStart)) + this.minStart;\n            }\n            next.config.rotSpeed = (Math.random() * (this.maxSpeed - this.minSpeed)) + this.minSpeed;\n            next = next.next;\n        }\n    }\n    updateParticle(particle, deltaSec) {\n        if (this.accel) {\n            const oldSpeed = particle.config.rotSpeed;\n            particle.config.rotSpeed += this.accel * deltaSec;\n            particle.rotation += (particle.config.rotSpeed + oldSpeed) / 2 * deltaSec;\n        }\n        else {\n            particle.rotation += particle.config.rotSpeed * deltaSec;\n        }\n    }\n}\nRotationBehavior.type = 'rotation';\nRotationBehavior.editorConfig = null;\n/**\n * A Rotation behavior that handles starting rotation.\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"rotationStatic\",\n *     \"config\": {\n *          \"min\": 0,\n *          \"max\": 180,\n *     }\n *}\n * ```\n */\nclass StaticRotationBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        this.min = config.min * DEG_TO_RADS;\n        this.max = config.max * DEG_TO_RADS;\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            if (this.min === this.max) {\n                next.rotation += this.max;\n            }\n            else {\n                next.rotation += (Math.random() * (this.max - this.min)) + this.min;\n            }\n            next = next.next;\n        }\n    }\n}\nStaticRotationBehavior.type = 'rotationStatic';\nStaticRotationBehavior.editorConfig = null;\n/**\n * A Rotation behavior that blocks all rotation caused by spawn settings,\n * by resetting it to the specified rotation (or 0).\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"noRotation\",\n *     \"config\": {\n *          \"rotation\": 0\n *     }\n *}\n * ```\n */\nclass NoRotationBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Late + 1;\n        this.rotation = (config.rotation || 0) * DEG_TO_RADS;\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            next.rotation = this.rotation;\n            next = next.next;\n        }\n    }\n}\nNoRotationBehavior.type = 'noRotation';\nNoRotationBehavior.editorConfig = null;\n\n/**\n * A Scale behavior that applies an interpolated or stepped list of values to the particle's x & y scale.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'scale',\n *     config: {\n *          scale: {\n *              list: [{value: 0, time: 0}, {value: 1, time: 0.25}, {value: 0, time: 1}],\n *              isStepped: true\n *          },\n *          minMult: 0.5\n *     }\n * }\n * ```\n */\nclass ScaleBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.scale));\n        this.minMult = config.minMult ?? 1;\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n            next.config.scaleMult = mult;\n            next.scale.x = next.scale.y = this.list.first.value * mult;\n            next = next.next;\n        }\n    }\n    updateParticle(particle) {\n        particle.scale.x = particle.scale.y = this.list.interpolate(particle.agePercent) * particle.config.scaleMult;\n    }\n}\nScaleBehavior.type = 'scale';\nScaleBehavior.editorConfig = null;\n/**\n * A Scale behavior that applies a randomly picked value to the particle's x & y scale at initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'scaleStatic',\n *     config: {\n *         min: 0.25,\n *         max: 0.75,\n *     }\n * }\n * ```\n */\nclass StaticScaleBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        this.min = config.min;\n        this.max = config.max;\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            const scale = (Math.random() * (this.max - this.min)) + this.min;\n            next.scale.x = next.scale.y = scale;\n            next = next.next;\n        }\n    }\n}\nStaticScaleBehavior.type = 'scaleStatic';\nStaticScaleBehavior.editorConfig = null;\n\n/**\n * A Spawn behavior that places (and optionally rotates) particles according to a\n * specified shape. Additional shapes can be registered with {@link registerShape | SpawnShape.registerShape()}.\n * Additional shapes must implement the {@link SpawnShape} interface, and their class must match the\n * {@link SpawnShapeClass} interface.\n * Shapes included by default are:\n * * {@link Rectangle}\n * * {@link Torus}\n * * {@link PolygonalChain}\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'spawnShape',\n *     config: {\n *          type: 'rect',\n *          data: {\n *              x: 0,\n *              y: 0,\n *              width: 20,\n *              height: 300,\n *          }\n *     }\n * }\n * ```\n */\nclass ShapeSpawnBehavior {\n    /**\n     * Registers a shape to be used by the ShapeSpawn behavior.\n     * @param constructor The shape class constructor to use, with a static `type` property to reference it by.\n     * @param typeOverride An optional type override, primarily for registering a shape under multiple names.\n     */\n    static registerShape(constructor, typeOverride) {\n        ShapeSpawnBehavior.shapes[typeOverride || constructor.type] = constructor;\n    }\n    constructor(config) {\n        this.order = BehaviorOrder.Spawn;\n        const ShapeClass = ShapeSpawnBehavior.shapes[config.type];\n        if (!ShapeClass) {\n            throw new Error(`No shape found with type '${config.type}'`);\n        }\n        this.shape = new ShapeClass(config.data);\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            this.shape.getRandPos(next);\n            next = next.next;\n        }\n    }\n}\nShapeSpawnBehavior.type = 'spawnShape';\nShapeSpawnBehavior.editorConfig = null;\n/**\n * Dictionary of all registered shape classes.\n */\nShapeSpawnBehavior.shapes = {};\nShapeSpawnBehavior.registerShape(PolygonalChain);\nShapeSpawnBehavior.registerShape(Rectangle);\nShapeSpawnBehavior.registerShape(Torus);\nShapeSpawnBehavior.registerShape(Torus, 'circle');\n\n/**\n * A Textuure behavior that assigns a single texture to each particle.\n * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'textureSingle',\n *     config: {\n *         texture: Texture.from('myTexId'),\n *     }\n * }\n * ```\n */\nclass SingleTextureBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Normal;\n        this.texture = typeof config.texture === 'string' ? GetTextureFromString(config.texture) : config.texture;\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            next.texture = this.texture;\n            next = next.next;\n        }\n    }\n}\nSingleTextureBehavior.type = 'textureSingle';\nSingleTextureBehavior.editorConfig = null;\n\n/**\n * A Movement behavior that uses an interpolated or stepped list of values for a particles speed at any given moment.\n * Movement direction is controlled by the particle's starting rotation.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'moveSpeed',\n *     config: {\n *          speed: {\n *              list: [{value: 10, time: 0}, {value: 100, time: 0.25}, {value: 0, time: 1}],\n *          },\n *          minMult: 0.8\n *     }\n * }\n * ```\n */\nclass SpeedBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Late;\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.speed));\n        this.minMult = config.minMult ?? 1;\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n            next.config.speedMult = mult;\n            if (!next.config.velocity) {\n                next.config.velocity = new Point(this.list.first.value * mult, 0);\n            }\n            else {\n                next.config.velocity.set(this.list.first.value * mult, 0);\n            }\n            rotatePoint(next.rotation, next.config.velocity);\n            next = next.next;\n        }\n    }\n    updateParticle(particle, deltaSec) {\n        const speed = this.list.interpolate(particle.agePercent) * particle.config.speedMult;\n        const vel = particle.config.velocity;\n        normalize(vel);\n        scaleBy(vel, speed);\n        particle.x += vel.x * deltaSec;\n        particle.y += vel.y * deltaSec;\n    }\n}\nSpeedBehavior.type = 'moveSpeed';\nSpeedBehavior.editorConfig = null;\n/**\n * A Movement behavior that uses a randomly picked constant speed throughout a particle's lifetime.\n * Movement direction is controlled by the particle's starting rotation.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'moveSpeedStatic',\n *     config: {\n *          min: 100,\n *          max: 150\n *     }\n * }\n * ```\n */\nclass StaticSpeedBehavior {\n    constructor(config) {\n        this.order = BehaviorOrder.Late;\n        this.min = config.min;\n        this.max = config.max;\n    }\n    initParticles(first) {\n        let next = first;\n        while (next) {\n            const speed = (Math.random() * (this.max - this.min)) + this.min;\n            if (!next.config.velocity) {\n                next.config.velocity = new Point(speed, 0);\n            }\n            else {\n                next.config.velocity.set(speed, 0);\n            }\n            rotatePoint(next.rotation, next.config.velocity);\n            next = next.next;\n        }\n    }\n    updateParticle(particle, deltaSec) {\n        const velocity = particle.config.velocity;\n        particle.x += velocity.x * deltaSec;\n        particle.y += velocity.y * deltaSec;\n    }\n}\nStaticSpeedBehavior.type = 'moveSpeedStatic';\nStaticSpeedBehavior.editorConfig = null;\n\n/**\n * An individual particle image. You shouldn't have to deal with these.\n */\nclass Particle extends Sprite {\n    /**\n     * @param emitter The emitter that controls this particle.\n     */\n    constructor(emitter) {\n        // start off the sprite with a blank texture, since we are going to replace it\n        // later when the particle is initialized.\n        super();\n        // initialize LinkedListChild props so they are included in underlying JS class definition\n        this.prevChild = this.nextChild = null;\n        this.emitter = emitter;\n        this.config = {};\n        // particles should be centered\n        this.anchor.x = this.anchor.y = 0.5;\n        this.maxLife = 0;\n        this.age = 0;\n        this.agePercent = 0;\n        this.oneOverLife = 0;\n        this.next = null;\n        this.prev = null;\n        // save often used functions on the instance instead of the prototype for better speed\n        this.init = this.init;\n        this.kill = this.kill;\n    }\n    /**\n     * Initializes the particle for use, based on the properties that have to\n     * have been set already on the particle.\n     */\n    init(maxLife) {\n        this.maxLife = maxLife;\n        // reset the age\n        this.age = this.agePercent = 0;\n        // reset the sprite props\n        this.rotation = 0;\n        this.position.x = this.position.y = 0;\n        this.scale.x = this.scale.y = 1;\n        this.tint = 0xffffff;\n        this.alpha = 1;\n        // save our lerp helper\n        this.oneOverLife = 1 / this.maxLife;\n        // ensure visibility\n        this.visible = true;\n    }\n    /**\n     * Kills the particle, removing it from the display list\n     * and telling the emitter to recycle it.\n     */\n    kill() {\n        this.emitter.recycle(this);\n    }\n    /**\n     * Destroys the particle, removing references and preventing future use.\n     */\n    destroy() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.emitter = this.next = this.prev = null;\n        super.destroy();\n    }\n}\n\n// get the shared ticker, only supports V5 and V6 with individual packages\n/**\n * @hidden\n */\nconst ticker = Ticker.shared;\n/**\n * Key used in sorted order to determine when to set particle position from the emitter position\n * and rotation.\n */\nconst PositionParticle = Symbol('Position particle per emitter position');\n/**\n * A particle emitter.\n */\nclass Emitter {\n    /**\n     * Registers a new behavior, so that it will be recognized when initializing emitters.\n     * Behaviors registered later with duplicate types will override older ones, although there is no limit on\n     * the allowed types.\n     * @param constructor The behavior class to register.\n     */\n    static registerBehavior(constructor) {\n        Emitter.knownBehaviors[constructor.type] = constructor;\n    }\n    /**\n     * @param particleParent The container to add the particles to.\n     * @param particleImages A texture or array of textures to use\n     *                       for the particles. Strings will be turned\n     *                       into textures via Texture.from().\n     * @param config A configuration object containing settings for the emitter.\n     * @param config.emit If config.emit is explicitly passed as false, the\n     *                    Emitter will start disabled.\n     * @param config.autoUpdate If config.autoUpdate is explicitly passed as\n     *                          true, the Emitter will automatically call\n     *                          update via the PIXI shared ticker.\n     */\n    constructor(particleParent, config) {\n        this.initBehaviors = [];\n        this.updateBehaviors = [];\n        this.recycleBehaviors = [];\n        // properties for individual particles\n        this.minLifetime = 0;\n        this.maxLifetime = 0;\n        this.customEase = null;\n        // properties for spawning particles\n        this._frequency = 1;\n        this.spawnChance = 1;\n        this.maxParticles = 1000;\n        this.emitterLifetime = -1;\n        this.spawnPos = new Point();\n        this.particlesPerWave = 1;\n        // emitter properties\n        this.rotation = 0;\n        this.ownerPos = new Point();\n        this._prevEmitterPos = new Point();\n        this._prevPosIsValid = false;\n        this._posChanged = false;\n        this._parent = null;\n        this.addAtBack = false;\n        this.particleCount = 0;\n        this._emit = false;\n        this._spawnTimer = 0;\n        this._emitterLife = -1;\n        this._activeParticlesFirst = null;\n        this._activeParticlesLast = null;\n        this._poolFirst = null;\n        this._origConfig = null;\n        this._autoUpdate = false;\n        this._destroyWhenComplete = false;\n        this._completeCallback = null;\n        // set the initial parent\n        this.parent = particleParent;\n        if (config) {\n            this.init(config);\n        }\n        // save often used functions on the instance instead of the prototype for better speed\n        this.recycle = this.recycle;\n        this.update = this.update;\n        this.rotate = this.rotate;\n        this.updateSpawnPos = this.updateSpawnPos;\n        this.updateOwnerPos = this.updateOwnerPos;\n    }\n    /**\n     * Time between particle spawns in seconds. If this value is not a number greater than 0,\n     * it will be set to 1 (particle per second) to prevent infinite loops.\n     */\n    get frequency() { return this._frequency; }\n    set frequency(value) {\n        // do some error checking to prevent infinite loops\n        if (typeof value === 'number' && value > 0) {\n            this._frequency = value;\n        }\n        else {\n            this._frequency = 1;\n        }\n    }\n    /**\n    * The container to add particles to. Settings this will dump any active particles.\n    */\n    get parent() { return this._parent; }\n    set parent(value) {\n        this.cleanup();\n        this._parent = value;\n    }\n    /**\n     * Sets up the emitter based on the config settings.\n     * @param config A configuration object containing settings for the emitter.\n     */\n    init(config) {\n        if (!config) {\n            return;\n        }\n        // clean up any existing particles\n        this.cleanup();\n        // store the original config and particle images, in case we need to re-initialize\n        // when the particle constructor is changed\n        this._origConfig = config;\n        // /////////////////////////\n        // Particle Properties    //\n        // /////////////////////////\n        // set up the lifetime\n        this.minLifetime = config.lifetime.min;\n        this.maxLifetime = config.lifetime.max;\n        // use the custom ease if provided\n        if (config.ease) {\n            this.customEase = typeof config.ease === 'function'\n                ? config.ease : generateEase(config.ease);\n        }\n        else {\n            this.customEase = null;\n        }\n        // ////////////////////////\n        // Emitter Properties    //\n        // ////////////////////////\n        // reset spawn type specific settings\n        this.particlesPerWave = 1;\n        if (config.particlesPerWave && config.particlesPerWave > 1) {\n            this.particlesPerWave = config.particlesPerWave;\n        }\n        // set the spawning frequency\n        this.frequency = config.frequency;\n        this.spawnChance = (typeof config.spawnChance === 'number' && config.spawnChance > 0) ? config.spawnChance : 1;\n        // set the emitter lifetime\n        this.emitterLifetime = config.emitterLifetime || -1;\n        // set the max particles\n        this.maxParticles = config.maxParticles > 0 ? config.maxParticles : 1000;\n        // determine if we should add the particle at the back of the list or not\n        this.addAtBack = !!config.addAtBack;\n        // reset the emitter position and rotation variables\n        this.rotation = 0;\n        this.ownerPos.set(0);\n        if (config.pos) {\n            this.spawnPos.copyFrom(config.pos);\n        }\n        else {\n            this.spawnPos.set(0);\n        }\n        this._prevEmitterPos.copyFrom(this.spawnPos);\n        // previous emitter position is invalid and should not be used for interpolation\n        this._prevPosIsValid = false;\n        // start emitting\n        this._spawnTimer = 0;\n        this.emit = config.emit === undefined ? true : !!config.emit;\n        this.autoUpdate = !!config.autoUpdate;\n        // ////////////////////////\n        // Behaviors             //\n        // ////////////////////////\n        const behaviors = config.behaviors.map((data) => {\n            const constructor = Emitter.knownBehaviors[data.type];\n            if (!constructor) {\n                console.error(`Unknown behavior: ${data.type}`);\n                return null;\n            }\n            return new constructor(data.config);\n        })\n            .filter((b) => !!b);\n        behaviors.push(PositionParticle);\n        behaviors.sort((a, b) => {\n            if (a === PositionParticle) {\n                return b.order === BehaviorOrder.Spawn ? 1 : -1;\n            }\n            else if (b === PositionParticle) {\n                return a.order === BehaviorOrder.Spawn ? -1 : 1;\n            }\n            return a.order - b.order;\n        });\n        this.initBehaviors = behaviors.slice();\n        this.updateBehaviors = behaviors.filter((b) => b !== PositionParticle && b.updateParticle);\n        this.recycleBehaviors = behaviors.filter((b) => b !== PositionParticle && b.recycleParticle);\n    }\n    /**\n     * Gets the instantiated behavior of the specified type, if it is present on this emitter.\n     * @param type The behavior type to find.\n     */\n    getBehavior(type) {\n        // bail if we don't know about such an emitter\n        if (!Emitter.knownBehaviors[type])\n            return null;\n        // find one that is an instance of the specified type\n        return this.initBehaviors.find((b) => b instanceof Emitter.knownBehaviors[type]) || null;\n    }\n    /**\n     * Fills the pool with the specified number of particles, so that they don't have to be instantiated later.\n     * @param count The number of particles to create.\n     */\n    fillPool(count) {\n        for (; count > 0; --count) {\n            const p = new Particle(this);\n            p.next = this._poolFirst;\n            this._poolFirst = p;\n        }\n    }\n    /**\n     * Recycles an individual particle. For internal use only.\n     * @param particle The particle to recycle.\n     * @param fromCleanup If this is being called to manually clean up all particles.\n     * @internal\n     */\n    recycle(particle, fromCleanup = false) {\n        for (let i = 0; i < this.recycleBehaviors.length; ++i) {\n            this.recycleBehaviors[i].recycleParticle(particle, !fromCleanup);\n        }\n        if (particle.next) {\n            particle.next.prev = particle.prev;\n        }\n        if (particle.prev) {\n            particle.prev.next = particle.next;\n        }\n        if (particle === this._activeParticlesLast) {\n            this._activeParticlesLast = particle.prev;\n        }\n        if (particle === this._activeParticlesFirst) {\n            this._activeParticlesFirst = particle.next;\n        }\n        // add to pool\n        particle.prev = null;\n        particle.next = this._poolFirst;\n        this._poolFirst = particle;\n        // remove child from display, or make it invisible if it is in a ParticleContainer\n        if (particle.parent) {\n            particle.parent.removeChild(particle);\n        }\n        // decrease count\n        --this.particleCount;\n    }\n    /**\n     * Sets the rotation of the emitter to a new value. This rotates the spawn position in addition\n     * to particle direction.\n     * @param newRot The new rotation, in degrees.\n     */\n    rotate(newRot) {\n        if (this.rotation === newRot)\n            return;\n        // caclulate the difference in rotation for rotating spawnPos\n        const diff = newRot - this.rotation;\n        this.rotation = newRot;\n        // rotate spawnPos\n        rotatePoint(diff, this.spawnPos);\n        // mark the position as having changed\n        this._posChanged = true;\n    }\n    /**\n     * Changes the spawn position of the emitter.\n     * @param x The new x value of the spawn position for the emitter.\n     * @param y The new y value of the spawn position for the emitter.\n     */\n    updateSpawnPos(x, y) {\n        this._posChanged = true;\n        this.spawnPos.x = x;\n        this.spawnPos.y = y;\n    }\n    /**\n     * Changes the position of the emitter's owner. You should call this if you are adding\n     * particles to the world container that your emitter's owner is moving around in.\n     * @param x The new x value of the emitter's owner.\n     * @param y The new y value of the emitter's owner.\n     */\n    updateOwnerPos(x, y) {\n        this._posChanged = true;\n        this.ownerPos.x = x;\n        this.ownerPos.y = y;\n    }\n    /**\n     * Prevents emitter position interpolation in the next update.\n     * This should be used if you made a major position change of your emitter's owner\n     * that was not normal movement.\n     */\n    resetPositionTracking() {\n        this._prevPosIsValid = false;\n    }\n    /**\n     * If particles should be emitted during update() calls. Setting this to false\n     * stops new particles from being created, but allows existing ones to die out.\n     */\n    get emit() { return this._emit; }\n    set emit(value) {\n        this._emit = !!value;\n        this._emitterLife = this.emitterLifetime;\n    }\n    /**\n     * If the update function is called automatically from the shared ticker.\n     * Setting this to false requires calling the update function manually.\n     */\n    get autoUpdate() { return this._autoUpdate; }\n    set autoUpdate(value) {\n        if (this._autoUpdate && !value) {\n            ticker.remove(this.update, this);\n        }\n        else if (!this._autoUpdate && value) {\n            ticker.add(this.update, this);\n        }\n        this._autoUpdate = !!value;\n    }\n    /**\n     * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself\n     * when particle emission is complete.\n     * @param callback Callback for when emission is complete (all particles have died off)\n     */\n    playOnceAndDestroy(callback) {\n        this.autoUpdate = true;\n        this.emit = true;\n        this._destroyWhenComplete = true;\n        this._completeCallback = callback;\n    }\n    /**\n     * Starts emitting particles and optionally calls a callback when particle emission is complete.\n     * @param callback Callback for when emission is complete (all particles have died off)\n     */\n    playOnce(callback) {\n        this.emit = true;\n        this._completeCallback = callback;\n    }\n    /**\n     * Updates all particles spawned by this emitter and emits new ones.\n     * @param delta Time elapsed since the previous frame, in __seconds__. Or Ticker instance for pixi.js v8.0.0\n     */\n    update(delta) {\n        if (typeof delta !== 'number') {\n            delta = delta.deltaTime;\n        }\n        if (this._autoUpdate) {\n            delta = ticker.elapsedMS * 0.001;\n        }\n        // if we don't have a parent to add particles to, then don't do anything.\n        // this also works as a isDestroyed check\n        if (!this._parent)\n            return;\n        // == update existing particles ==\n        // update all particle lifetimes before turning them over to behaviors\n        for (let particle = this._activeParticlesFirst, next; particle; particle = next) {\n            // save next particle in case we recycle this one\n            next = particle.next;\n            // increase age\n            particle.age += delta;\n            // recycle particle if it is too old\n            if (particle.age > particle.maxLife || particle.age < 0) {\n                this.recycle(particle);\n            }\n            else {\n                // determine our interpolation value\n                let lerp = particle.age * particle.oneOverLife; // lifetime / maxLife;\n                // global ease affects all interpolation calculations\n                if (this.customEase) {\n                    if (this.customEase.length === 4) {\n                        // the t, b, c, d parameters that some tween libraries use\n                        // (time, initial value, end value, duration)\n                        lerp = this.customEase(lerp, 0, 1, 1);\n                    }\n                    else {\n                        // the simplified version that we like that takes\n                        // one parameter, time from 0-1. TweenJS eases provide this usage.\n                        lerp = this.customEase(lerp);\n                    }\n                }\n                // set age percent for all interpolation calculations\n                particle.agePercent = lerp;\n                // let each behavior run wild on the active particles\n                for (let i = 0; i < this.updateBehaviors.length; ++i) {\n                    if (this.updateBehaviors[i].updateParticle(particle, delta)) {\n                        this.recycle(particle);\n                        break;\n                    }\n                }\n            }\n        }\n        let prevX;\n        let prevY;\n        // if the previous position is valid, store these for later interpolation\n        if (this._prevPosIsValid) {\n            prevX = this._prevEmitterPos.x;\n            prevY = this._prevEmitterPos.y;\n        }\n        // store current position of the emitter as local variables\n        const curX = this.ownerPos.x + this.spawnPos.x;\n        const curY = this.ownerPos.y + this.spawnPos.y;\n        // spawn new particles\n        if (this._emit) {\n            // decrease spawn timer\n            this._spawnTimer -= delta < 0 ? 0 : delta;\n            // while _spawnTimer < 0, we have particles to spawn\n            while (this._spawnTimer <= 0) {\n                // determine if the emitter should stop spawning\n                if (this._emitterLife >= 0) {\n                    this._emitterLife -= this._frequency;\n                    if (this._emitterLife <= 0) {\n                        this._spawnTimer = 0;\n                        this._emitterLife = 0;\n                        this.emit = false;\n                        break;\n                    }\n                }\n                // determine if we have hit the particle limit\n                if (this.particleCount >= this.maxParticles) {\n                    this._spawnTimer += this._frequency;\n                    continue;\n                }\n                let emitPosX;\n                let emitPosY;\n                // If the position has changed and this isn't the first spawn,\n                // interpolate the spawn position\n                if (this._prevPosIsValid && this._posChanged) {\n                    // 1 - _spawnTimer / delta, but _spawnTimer is negative\n                    const lerp = 1 + (this._spawnTimer / delta);\n                    emitPosX = ((curX - prevX) * lerp) + prevX;\n                    emitPosY = ((curY - prevY) * lerp) + prevY;\n                }\n                // otherwise just set to the spawn position\n                else {\n                    emitPosX = curX;\n                    emitPosY = curY;\n                }\n                let waveFirst = null;\n                let waveLast = null;\n                // create enough particles to fill the wave\n                for (let len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), i = 0; i < len; ++i) {\n                    // see if we actually spawn one\n                    if (this.spawnChance < 1 && Math.random() >= this.spawnChance) {\n                        continue;\n                    }\n                    // determine the particle lifetime\n                    let lifetime;\n                    if (this.minLifetime === this.maxLifetime) {\n                        lifetime = this.minLifetime;\n                    }\n                    else {\n                        lifetime = (Math.random() * (this.maxLifetime - this.minLifetime)) + this.minLifetime;\n                    }\n                    // only make the particle if it wouldn't immediately destroy itself\n                    if (-this._spawnTimer >= lifetime) {\n                        continue;\n                    }\n                    // create particle\n                    let p;\n                    if (this._poolFirst) {\n                        p = this._poolFirst;\n                        this._poolFirst = this._poolFirst.next;\n                        p.next = null;\n                    }\n                    else {\n                        p = new Particle(this);\n                    }\n                    // initialize particle\n                    p.init(lifetime);\n                    // add the particle to the display list\n                    if (this.addAtBack) {\n                        this._parent.addChildAt(p, 0);\n                    }\n                    else {\n                        this._parent.addChild(p);\n                    }\n                    // add particles to list of ones in this wave\n                    if (waveFirst) {\n                        waveLast.next = p;\n                        p.prev = waveLast;\n                        waveLast = p;\n                    }\n                    else {\n                        waveLast = waveFirst = p;\n                    }\n                    // increase our particle count\n                    ++this.particleCount;\n                }\n                if (waveFirst) {\n                    // add particle to list of active particles\n                    if (this._activeParticlesLast) {\n                        this._activeParticlesLast.next = waveFirst;\n                        waveFirst.prev = this._activeParticlesLast;\n                        this._activeParticlesLast = waveLast;\n                    }\n                    else {\n                        this._activeParticlesFirst = waveFirst;\n                        this._activeParticlesLast = waveLast;\n                    }\n                    // run behavior init on particles\n                    for (let i = 0; i < this.initBehaviors.length; ++i) {\n                        const behavior = this.initBehaviors[i];\n                        // if we hit our special key, interrupt behaviors to apply\n                        // emitter position/rotation\n                        if (behavior === PositionParticle) {\n                            for (let particle = waveFirst, next; particle; particle = next) {\n                                // save next particle in case we recycle this one\n                                next = particle.next;\n                                // rotate the particle's position by the emitter's rotation\n                                if (this.rotation !== 0) {\n                                    rotatePoint(this.rotation, particle.position);\n                                    particle.rotation += this.rotation;\n                                }\n                                // offset by the emitter's position\n                                particle.position.x += emitPosX;\n                                particle.position.y += emitPosY;\n                                // also, just update the particle's age properties while we are looping through\n                                particle.age += -this._spawnTimer;\n                                // determine our interpolation value\n                                let lerp = particle.age * particle.oneOverLife; // lifetime / maxLife;\n                                // global ease affects all interpolation calculations\n                                if (this.customEase) {\n                                    if (this.customEase.length === 4) {\n                                        // the t, b, c, d parameters that some tween libraries use\n                                        // (time, initial value, end value, duration)\n                                        lerp = this.customEase(lerp, 0, 1, 1);\n                                    }\n                                    else {\n                                        // the simplified version that we like that takes\n                                        // one parameter, time from 0-1. TweenJS eases provide this usage.\n                                        lerp = this.customEase(lerp);\n                                    }\n                                }\n                                // set age percent for all interpolation calculations\n                                particle.agePercent = lerp;\n                            }\n                        }\n                        else {\n                            behavior.initParticles(waveFirst);\n                        }\n                    }\n                    for (let particle = waveFirst, next; particle; particle = next) {\n                        // save next particle in case we recycle this one\n                        next = particle.next;\n                        // now update the particles by the time passed, so the particles are spread out properly\n                        for (let i = 0; i < this.updateBehaviors.length; ++i) {\n                            // we want a positive delta, because a negative delta messes things up\n                            if (this.updateBehaviors[i].updateParticle(particle, -this._spawnTimer)) {\n                                // bail if the particle got reycled\n                                this.recycle(particle);\n                                break;\n                            }\n                        }\n                    }\n                }\n                // increase timer and continue on to any other particles that need to be created\n                this._spawnTimer += this._frequency;\n            }\n        }\n        // if the position changed before this update, then keep track of that\n        if (this._posChanged) {\n            this._prevEmitterPos.x = curX;\n            this._prevEmitterPos.y = curY;\n            this._prevPosIsValid = true;\n            this._posChanged = false;\n        }\n        // if we are all done and should destroy ourselves, take care of that\n        if (!this._emit && !this._activeParticlesFirst) {\n            if (this._completeCallback) {\n                const cb = this._completeCallback;\n                this._completeCallback = null;\n                cb();\n            }\n            if (this._destroyWhenComplete) {\n                this.destroy();\n            }\n        }\n    }\n    /**\n     * Emits a single wave of particles, using standard spawnChance & particlesPerWave settings. Does not affect\n     * regular spawning through the frequency, and ignores the emit property. The max particle count is respected, however,\n     * so if there are already too many particles then nothing will happen.\n     */\n    emitNow() {\n        const emitPosX = this.ownerPos.x + this.spawnPos.x;\n        const emitPosY = this.ownerPos.y + this.spawnPos.y;\n        let waveFirst = null;\n        let waveLast = null;\n        // create enough particles to fill the wave\n        for (let len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), i = 0; i < len; ++i) {\n            // see if we actually spawn one\n            if (this.spawnChance < 1 && Math.random() >= this.spawnChance) {\n                continue;\n            }\n            // create particle\n            let p;\n            if (this._poolFirst) {\n                p = this._poolFirst;\n                this._poolFirst = this._poolFirst.next;\n                p.next = null;\n            }\n            else {\n                p = new Particle(this);\n            }\n            let lifetime;\n            if (this.minLifetime === this.maxLifetime) {\n                lifetime = this.minLifetime;\n            }\n            else {\n                lifetime = (Math.random() * (this.maxLifetime - this.minLifetime)) + this.minLifetime;\n            }\n            // initialize particle\n            p.init(lifetime);\n            // add the particle to the display list\n            if (this.addAtBack) {\n                this._parent.addChildAt(p, 0);\n            }\n            else {\n                this._parent.addChild(p);\n            }\n            // add particles to list of ones in this wave\n            if (waveFirst) {\n                waveLast.next = p;\n                p.prev = waveLast;\n                waveLast = p;\n            }\n            else {\n                waveLast = waveFirst = p;\n            }\n            // increase our particle count\n            ++this.particleCount;\n        }\n        if (waveFirst) {\n            // add particle to list of active particles\n            if (this._activeParticlesLast) {\n                this._activeParticlesLast.next = waveFirst;\n                waveFirst.prev = this._activeParticlesLast;\n                this._activeParticlesLast = waveLast;\n            }\n            else {\n                this._activeParticlesFirst = waveFirst;\n                this._activeParticlesLast = waveLast;\n            }\n            // run behavior init on particles\n            for (let i = 0; i < this.initBehaviors.length; ++i) {\n                const behavior = this.initBehaviors[i];\n                // if we hit our special key, interrupt behaviors to apply\n                // emitter position/rotation\n                if (behavior === PositionParticle) {\n                    for (let particle = waveFirst, next; particle; particle = next) {\n                        // save next particle in case we recycle this one\n                        next = particle.next;\n                        // rotate the particle's position by the emitter's rotation\n                        if (this.rotation !== 0) {\n                            rotatePoint(this.rotation, particle.position);\n                            particle.rotation += this.rotation;\n                        }\n                        // offset by the emitter's position\n                        particle.position.x += emitPosX;\n                        particle.position.y += emitPosY;\n                    }\n                }\n                else {\n                    behavior.initParticles(waveFirst);\n                }\n            }\n        }\n    }\n    /**\n     * Kills all active particles immediately.\n     */\n    cleanup() {\n        let particle;\n        let next;\n        for (particle = this._activeParticlesFirst; particle; particle = next) {\n            next = particle.next;\n            this.recycle(particle, true);\n        }\n        this._activeParticlesFirst = this._activeParticlesLast = null;\n        this.particleCount = 0;\n    }\n    /**\n     * If this emitter has been destroyed. Note that a destroyed emitter can still be reused, after\n     * having a new parent set and being reinitialized.\n     */\n    get destroyed() {\n        return !(this._parent && this.initBehaviors.length);\n    }\n    /**\n     * Destroys the emitter and all of its particles.\n     */\n    destroy() {\n        // make sure we aren't still listening to any tickers\n        this.autoUpdate = false;\n        // puts all active particles in the pool, and removes them from the particle parent\n        this.cleanup();\n        // wipe the pool clean\n        let next;\n        for (let particle = this._poolFirst; particle; particle = next) {\n            // store next value so we don't lose it in our destroy call\n            next = particle.next;\n            particle.destroy();\n        }\n        this._poolFirst = this._parent = this.spawnPos = this.ownerPos\n            = this.customEase = this._completeCallback = null;\n        this.initBehaviors.length = this.updateBehaviors.length = this.recycleBehaviors.length = 0;\n    }\n}\nEmitter.knownBehaviors = {};\n\n/**\n * Converts emitter configuration from pre-5.0.0 library values into the current version.\n *\n * Example usage:\n * ```javascript\n * const emitter = new Emitter(myContainer, upgradeConfig(myOldConfig, [myTexture, myOtherTexture]));\n * ```\n * @param config The old emitter config to upgrade.\n * @param art The old art values as would have been passed into the Emitter constructor or `Emitter.init()`\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction upgradeConfig(config, art) {\n    // just ensure we aren't given any V3 config data\n    if ('behaviors' in config) {\n        return config;\n    }\n    const out = {\n        lifetime: config.lifetime,\n        ease: config.ease,\n        particlesPerWave: config.particlesPerWave,\n        frequency: config.frequency,\n        spawnChance: config.spawnChance,\n        emitterLifetime: config.emitterLifetime,\n        maxParticles: config.maxParticles,\n        addAtBack: config.addAtBack,\n        pos: config.pos,\n        emit: config.emit,\n        autoUpdate: config.autoUpdate,\n        behaviors: [],\n    };\n    // set up the alpha\n    if (config.alpha) {\n        if ('start' in config.alpha) {\n            if (config.alpha.start === config.alpha.end) {\n                if (config.alpha.start !== 1) {\n                    out.behaviors.push({\n                        type: 'alphaStatic',\n                        config: { alpha: config.alpha.start },\n                    });\n                }\n            }\n            else {\n                const list = {\n                    list: [\n                        { time: 0, value: config.alpha.start },\n                        { time: 1, value: config.alpha.end },\n                    ],\n                };\n                out.behaviors.push({\n                    type: 'alpha',\n                    config: { alpha: list },\n                });\n            }\n        }\n        else if (config.alpha.list.length === 1) {\n            if (config.alpha.list[0].value !== 1) {\n                out.behaviors.push({\n                    type: 'alphaStatic',\n                    config: { alpha: config.alpha.list[0].value },\n                });\n            }\n        }\n        else {\n            out.behaviors.push({\n                type: 'alpha',\n                config: { alpha: config.alpha },\n            });\n        }\n    }\n    // acceleration movement\n    if (config.acceleration && (config.acceleration.x || config.acceleration.y)) {\n        let minStart;\n        let maxStart;\n        if ('start' in config.speed) {\n            minStart = config.speed.start * (config.speed.minimumSpeedMultiplier ?? 1);\n            maxStart = config.speed.start;\n        }\n        else {\n            minStart = config.speed.list[0].value * (config.minimumSpeedMultiplier ?? 1);\n            maxStart = config.speed.list[0].value;\n        }\n        out.behaviors.push({\n            type: 'moveAcceleration',\n            config: {\n                accel: config.acceleration,\n                minStart,\n                maxStart,\n                rotate: !config.noRotation,\n                maxSpeed: config.maxSpeed,\n            },\n        });\n    }\n    // path movement\n    else if (config.extraData?.path) {\n        let list;\n        let mult;\n        if ('start' in config.speed) {\n            mult = config.speed.minimumSpeedMultiplier ?? 1;\n            if (config.speed.start === config.speed.end) {\n                list = {\n                    list: [{ time: 0, value: config.speed.start }],\n                };\n            }\n            else {\n                list = {\n                    list: [\n                        { time: 0, value: config.speed.start },\n                        { time: 1, value: config.speed.end },\n                    ],\n                };\n            }\n        }\n        else {\n            list = config.speed;\n            mult = (config.minimumSpeedMultiplier ?? 1);\n        }\n        out.behaviors.push({\n            type: 'movePath',\n            config: {\n                path: config.extraData.path,\n                speed: list,\n                minMult: mult,\n            },\n        });\n    }\n    // normal speed movement\n    else {\n        if (config.speed) {\n            if ('start' in config.speed) {\n                if (config.speed.start === config.speed.end) {\n                    out.behaviors.push({\n                        type: 'moveSpeedStatic',\n                        config: {\n                            min: config.speed.start * (config.speed.minimumSpeedMultiplier ?? 1),\n                            max: config.speed.start,\n                        },\n                    });\n                }\n                else {\n                    const list = {\n                        list: [\n                            { time: 0, value: config.speed.start },\n                            { time: 1, value: config.speed.end },\n                        ],\n                    };\n                    out.behaviors.push({\n                        type: 'moveSpeed',\n                        config: { speed: list, minMult: config.speed.minimumSpeedMultiplier },\n                    });\n                }\n            }\n            else if (config.speed.list.length === 1) {\n                out.behaviors.push({\n                    type: 'moveSpeedStatic',\n                    config: {\n                        min: config.speed.list[0].value * (config.minimumSpeedMultiplier ?? 1),\n                        max: config.speed.list[0].value,\n                    },\n                });\n            }\n            else {\n                out.behaviors.push({\n                    type: 'moveSpeed',\n                    config: { speed: config.speed, minMult: (config.minimumSpeedMultiplier ?? 1) },\n                });\n            }\n        }\n    }\n    // scale\n    if (config.scale) {\n        if ('start' in config.scale) {\n            const mult = config.scale.minimumScaleMultiplier ?? 1;\n            if (config.scale.start === config.scale.end) {\n                out.behaviors.push({\n                    type: 'scaleStatic',\n                    config: {\n                        min: config.scale.start * mult,\n                        max: config.scale.start,\n                    },\n                });\n            }\n            else {\n                const list = {\n                    list: [\n                        { time: 0, value: config.scale.start },\n                        { time: 1, value: config.scale.end },\n                    ],\n                };\n                out.behaviors.push({\n                    type: 'scale',\n                    config: { scale: list, minMult: mult },\n                });\n            }\n        }\n        else if (config.scale.list.length === 1) {\n            const mult = config.minimumScaleMultiplier ?? 1;\n            const scale = config.scale.list[0].value;\n            out.behaviors.push({\n                type: 'scaleStatic',\n                config: { min: scale * mult, max: scale },\n            });\n        }\n        else {\n            out.behaviors.push({\n                type: 'scale',\n                config: { scale: config.scale, minMult: config.minimumScaleMultiplier ?? 1 },\n            });\n        }\n    }\n    // color\n    if (config.color) {\n        if ('start' in config.color) {\n            if (config.color.start === config.color.end) {\n                if (config.color.start !== 'ffffff') {\n                    out.behaviors.push({\n                        type: 'colorStatic',\n                        config: { color: config.color.start },\n                    });\n                }\n            }\n            else {\n                const list = {\n                    list: [\n                        { time: 0, value: config.color.start },\n                        { time: 1, value: config.color.end },\n                    ],\n                };\n                out.behaviors.push({\n                    type: 'color',\n                    config: { color: list },\n                });\n            }\n        }\n        else if (config.color.list.length === 1) {\n            if (config.color.list[0].value !== 'ffffff') {\n                out.behaviors.push({\n                    type: 'colorStatic',\n                    config: { color: config.color.list[0].value },\n                });\n            }\n        }\n        else {\n            out.behaviors.push({\n                type: 'color',\n                config: { color: config.color },\n            });\n        }\n    }\n    // rotation\n    if (config.rotationAcceleration || config.rotationSpeed?.min || config.rotationSpeed?.max) {\n        out.behaviors.push({\n            type: 'rotation',\n            config: {\n                accel: config.rotationAcceleration || 0,\n                minSpeed: config.rotationSpeed?.min || 0,\n                maxSpeed: config.rotationSpeed?.max || 0,\n                minStart: config.startRotation?.min || 0,\n                maxStart: config.startRotation?.max || 0,\n            },\n        });\n    }\n    else if (config.startRotation?.min || config.startRotation?.max) {\n        out.behaviors.push({\n            type: 'rotationStatic',\n            config: {\n                min: config.startRotation?.min || 0,\n                max: config.startRotation?.max || 0,\n            },\n        });\n    }\n    if (config.noRotation) {\n        out.behaviors.push({\n            type: 'noRotation',\n            config: {},\n        });\n    }\n    // blend mode\n    if (config.blendMode && config.blendMode !== 'normal') {\n        out.behaviors.push({\n            type: 'blendMode',\n            config: {\n                blendMode: config.blendMode,\n            },\n        });\n    }\n    // animated\n    if (Array.isArray(art) && typeof art[0] !== 'string' && 'framerate' in art[0]) {\n        for (let i = 0; i < art.length; ++i) {\n            if (art[i].framerate === 'matchLife') {\n                art[i].framerate = -1;\n            }\n        }\n        out.behaviors.push({\n            type: 'animatedRandom',\n            config: {\n                anims: art,\n            },\n        });\n    }\n    else if (typeof art !== 'string' && 'framerate' in art) {\n        if (art.framerate === 'matchLife') {\n            art.framerate = -1;\n        }\n        out.behaviors.push({\n            type: 'animatedSingle',\n            config: {\n                anim: art,\n            },\n        });\n    }\n    // ordered art\n    else if (config.orderedArt && Array.isArray(art)) {\n        out.behaviors.push({\n            type: 'textureOrdered',\n            config: {\n                textures: art,\n            },\n        });\n    }\n    // random texture\n    else if (Array.isArray(art)) {\n        out.behaviors.push({\n            type: 'textureRandom',\n            config: {\n                textures: art,\n            },\n        });\n    }\n    // single texture\n    else {\n        out.behaviors.push({\n            type: 'textureSingle',\n            config: {\n                texture: art,\n            },\n        });\n    }\n    // spawn burst\n    if (config.spawnType === 'burst') {\n        out.behaviors.push({\n            type: 'spawnBurst',\n            config: {\n                start: config.angleStart || 0,\n                spacing: config.particleSpacing,\n                // older formats bursted from a single point\n                distance: 0,\n            },\n        });\n    }\n    // spawn point\n    else if (config.spawnType === 'point') {\n        out.behaviors.push({\n            type: 'spawnPoint',\n            config: {},\n        });\n    }\n    // spawn shape\n    else {\n        let shape;\n        if (config.spawnType === 'ring') {\n            shape = {\n                type: 'torus',\n                data: {\n                    x: config.spawnCircle.x,\n                    y: config.spawnCircle.y,\n                    radius: config.spawnCircle.r,\n                    innerRadius: config.spawnCircle.minR,\n                    affectRotation: true,\n                },\n            };\n        }\n        else if (config.spawnType === 'circle') {\n            shape = {\n                type: 'torus',\n                data: {\n                    x: config.spawnCircle.x,\n                    y: config.spawnCircle.y,\n                    radius: config.spawnCircle.r,\n                    innerRadius: 0,\n                    affectRotation: false,\n                },\n            };\n        }\n        else if (config.spawnType === 'rect') {\n            shape = {\n                type: 'rect',\n                data: config.spawnRect,\n            };\n        }\n        else if (config.spawnType === 'polygonalChain') {\n            shape = {\n                type: 'polygonalChain',\n                data: config.spawnPolygon,\n            };\n        }\n        if (shape) {\n            out.behaviors.push({\n                type: 'spawnShape',\n                config: shape,\n            });\n        }\n    }\n    return out;\n}\n\nEmitter.registerBehavior(AccelerationBehavior);\nEmitter.registerBehavior(AlphaBehavior);\nEmitter.registerBehavior(StaticAlphaBehavior);\nEmitter.registerBehavior(RandomAnimatedTextureBehavior);\nEmitter.registerBehavior(SingleAnimatedTextureBehavior);\nEmitter.registerBehavior(BlendModeBehavior);\nEmitter.registerBehavior(BurstSpawnBehavior);\nEmitter.registerBehavior(ColorBehavior);\nEmitter.registerBehavior(StaticColorBehavior);\nEmitter.registerBehavior(OrderedTextureBehavior);\nEmitter.registerBehavior(PathBehavior);\nEmitter.registerBehavior(PointSpawnBehavior);\nEmitter.registerBehavior(RandomTextureBehavior);\nEmitter.registerBehavior(RotationBehavior);\nEmitter.registerBehavior(StaticRotationBehavior);\nEmitter.registerBehavior(NoRotationBehavior);\nEmitter.registerBehavior(ScaleBehavior);\nEmitter.registerBehavior(StaticScaleBehavior);\nEmitter.registerBehavior(ShapeSpawnBehavior);\nEmitter.registerBehavior(SingleTextureBehavior);\nEmitter.registerBehavior(SpeedBehavior);\nEmitter.registerBehavior(StaticSpeedBehavior);\n\nexport { Emitter, Particle, ParticleUtils, PropertyList, PropertyNode, upgradeConfig };\n//# sourceMappingURL=particle-emitter.es.js.map\n"],
  "mappings": "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",
  "names": ["value", "time", "BehaviorOrder"]
}
