import "./chunk-NVO3SAKV.js";
import "./chunk-URFZLKA3.js";
import "./chunk-YTOKF43M.js";
import "./chunk-56PQPBCD.js";
import "./chunk-BKMQP45E.js";
import "./chunk-D4A2AHLG.js";
import "./chunk-R5U2K7GU.js";
import {
  Point,
  Sprite,
  Texture,
  Ticker
} from "./chunk-4XPZJGK3.js";
import "./chunk-SROXYCZ4.js";

// ../../node_modules/.pnpm/@barvynkoa+particle-emitter@0.0.1_pixi.js@8.8.1/node_modules/@barvynkoa/particle-emitter/lib/particle-emitter.es.js
var PolygonalChain = class {
  /**
   * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.
   */
  constructor(data) {
    this.segments = [];
    this.countingLengths = [];
    this.totalLength = 0;
    this.init(data);
  }
  /**
   * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.
   */
  init(data) {
    if (!data || !data.length) {
      this.segments.push({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 }, l: 0 });
    } else if (Array.isArray(data[0])) {
      for (let i = 0; i < data.length; ++i) {
        const chain = data[i];
        let prevPoint = chain[0];
        for (let j = 1; j < chain.length; ++j) {
          const second = chain[j];
          this.segments.push({ p1: prevPoint, p2: second, l: 0 });
          prevPoint = second;
        }
      }
    } else {
      let prevPoint = data[0];
      for (let i = 1; i < data.length; ++i) {
        const second = data[i];
        this.segments.push({ p1: prevPoint, p2: second, l: 0 });
        prevPoint = second;
      }
    }
    for (let i = 0; i < this.segments.length; ++i) {
      const { p1, p2 } = this.segments[i];
      const segLength = Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
      this.segments[i].l = segLength;
      this.totalLength += segLength;
      this.countingLengths.push(this.totalLength);
    }
  }
  /**
   * Gets a random point in the chain.
   * @param out - Particle ?, because was point data
   */
  getRandPos(out) {
    const rand = Math.random() * this.totalLength;
    let chosenSeg;
    let lerp;
    if (this.segments.length === 1) {
      chosenSeg = this.segments[0];
      lerp = rand;
    } else {
      for (let i = 0; i < this.countingLengths.length; ++i) {
        if (rand < this.countingLengths[i]) {
          chosenSeg = this.segments[i];
          lerp = i === 0 ? rand : rand - this.countingLengths[i - 1];
          break;
        }
      }
    }
    lerp /= chosenSeg.l || 1;
    const { p1, p2 } = chosenSeg;
    out.x = p1.x + lerp * (p2.x - p1.x);
    out.y = p1.y + lerp * (p2.y - p1.y);
  }
};
PolygonalChain.type = "polygonalChain";
PolygonalChain.editorConfig = null;
var Rectangle = class {
  constructor(config) {
    this.x = config.x;
    this.y = config.y;
    this.w = config.w;
    this.h = config.h;
  }
  getRandPos(particle) {
    particle.x = Math.random() * this.w + this.x;
    particle.y = Math.random() * this.h + this.y;
  }
};
Rectangle.type = "rect";
Rectangle.editorConfig = null;
var PropertyNode = class _PropertyNode {
  /**
   * @param value The value for this node
   * @param time The time for this node, between 0-1
   * @param [ease] Custom ease for this list. Only relevant for the first node.
   */
  constructor(value, time, ease) {
    this.value = value;
    this.time = time;
    this.next = null;
    this.isStepped = false;
    if (ease) {
      this.ease = typeof ease === "function" ? ease : generateEase(ease);
    } else {
      this.ease = null;
    }
  }
  /**
   * Creates a list of property values from a data object {list, isStepped} with a list of objects in
   * the form {value, time}. Alternatively, the data object can be in the deprecated form of
   * {start, end}.
   * @param data The data for the list.
   * @param data.list The array of value and time objects.
   * @param data.isStepped If the list is stepped rather than interpolated.
   * @param data.ease Custom ease for this list.
   * @return The first node in the list
   */
  // eslint-disable-next-line max-len
  static createList(data) {
    if ("list" in data) {
      const array = data.list;
      let node;
      const { value, time } = array[0];
      const first = node = new _PropertyNode(typeof value === "string" ? hexToRGB(value) : value, time, data.ease);
      if (array.length > 2 || array.length === 2 && array[1].value !== value) {
        for (let i = 1; i < array.length; ++i) {
          const { value: value2, time: time2 } = array[i];
          node.next = new _PropertyNode(typeof value2 === "string" ? hexToRGB(value2) : value2, time2);
          node = node.next;
        }
      }
      first.isStepped = !!data.isStepped;
      return first;
    }
    const start = new _PropertyNode(typeof data.start === "string" ? hexToRGB(data.start) : data.start, 0);
    if (data.end !== data.start) {
      start.next = new _PropertyNode(typeof data.end === "string" ? hexToRGB(data.end) : data.end, 1);
    }
    return start;
  }
};
var GetTextureFromString = Texture.from;
var verbose = false;
var DEG_TO_RADS = Math.PI / 180;
function rotatePoint(angle, p) {
  if (!angle)
    return;
  const s = Math.sin(angle);
  const c = Math.cos(angle);
  const xnew = p.x * c - p.y * s;
  const ynew = p.x * s + p.y * c;
  p.x = xnew;
  p.y = ynew;
}
function combineRGBComponents(r, g, b) {
  return (
    /* a << 24 |*/
    r << 16 | g << 8 | b
  );
}
function length(point) {
  return Math.sqrt(point.x * point.x + point.y * point.y);
}
function normalize(point) {
  const oneOverLen = 1 / length(point);
  point.x *= oneOverLen;
  point.y *= oneOverLen;
}
function scaleBy(point, value) {
  point.x *= value;
  point.y *= value;
}
function hexToRGB(color, output) {
  if (!output) {
    output = {};
  }
  if (color.charAt(0) === "#") {
    color = color.substr(1);
  } else if (color.indexOf("0x") === 0) {
    color = color.substr(2);
  }
  let alpha;
  if (color.length === 8) {
    alpha = color.substr(0, 2);
    color = color.substr(2);
  }
  output.r = parseInt(color.substr(0, 2), 16);
  output.g = parseInt(color.substr(2, 2), 16);
  output.b = parseInt(color.substr(4, 2), 16);
  if (alpha) {
    output.a = parseInt(alpha, 16);
  }
  return output;
}
function generateEase(segments) {
  const qty = segments.length;
  const oneOverQty = 1 / qty;
  return function(time) {
    const i = qty * time | 0;
    const t = (time - i * oneOverQty) * qty;
    const s = segments[i] || segments[qty - 1];
    return s.s + t * (2 * (1 - t) * (s.cp - s.s) + t * (s.e - s.s));
  };
}
function getBlendMode(name) {
  return name || "normal";
}
function createSteppedGradient(list, numSteps = 10) {
  if (typeof numSteps !== "number" || numSteps <= 0) {
    numSteps = 10;
  }
  const first = new PropertyNode(hexToRGB(list[0].value), list[0].time);
  first.isStepped = true;
  let currentNode = first;
  let current = list[0];
  let nextIndex = 1;
  let next = list[nextIndex];
  for (let i = 1; i < numSteps; ++i) {
    let lerp = i / numSteps;
    while (lerp > next.time) {
      current = next;
      next = list[++nextIndex];
    }
    lerp = (lerp - current.time) / (next.time - current.time);
    const curVal = hexToRGB(current.value);
    const nextVal = hexToRGB(next.value);
    const output = {
      r: (nextVal.r - curVal.r) * lerp + curVal.r,
      g: (nextVal.g - curVal.g) * lerp + curVal.g,
      b: (nextVal.b - curVal.b) * lerp + curVal.b
    };
    currentNode.next = new PropertyNode(output, i / numSteps);
    currentNode = currentNode.next;
  }
  return first;
}
var ParticleUtils = {
  __proto__: null,
  DEG_TO_RADS,
  GetTextureFromString,
  combineRGBComponents,
  createSteppedGradient,
  generateEase,
  getBlendMode,
  hexToRGB,
  length,
  normalize,
  rotatePoint,
  scaleBy,
  verbose
};
var Torus = class {
  constructor(config) {
    this.x = config.x || 0;
    this.y = config.y || 0;
    this.radius = config.radius;
    this.innerRadius = config.innerRadius || 0;
    this.rotation = !!config.affectRotation;
  }
  getRandPos(particle) {
    if (this.innerRadius !== this.radius) {
      particle.x = Math.random() * (this.radius - this.innerRadius) + this.innerRadius;
    } else {
      particle.x = this.radius;
    }
    particle.y = 0;
    const angle = Math.random() * Math.PI * 2;
    if (this.rotation) {
      particle.rotation += angle;
    }
    rotatePoint(angle, particle.position);
    particle.position.x += this.x;
    particle.position.y += this.y;
  }
};
Torus.type = "torus";
Torus.editorConfig = null;
var BehaviorOrder;
(function(BehaviorOrder2) {
  BehaviorOrder2[BehaviorOrder2["Spawn"] = 0] = "Spawn";
  BehaviorOrder2[BehaviorOrder2["Normal"] = 2] = "Normal";
  BehaviorOrder2[BehaviorOrder2["Late"] = 5] = "Late";
})(BehaviorOrder || (BehaviorOrder = {}));
var AccelerationBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Late;
    this.minStart = config.minStart;
    this.maxStart = config.maxStart;
    this.accel = config.accel;
    this.rotate = !!config.rotate;
    this.maxSpeed = config.maxSpeed ?? 0;
  }
  initParticles(first) {
    let next = first;
    while (next) {
      const speed = Math.random() * (this.maxStart - this.minStart) + this.minStart;
      if (!next.config.velocity) {
        next.config.velocity = new Point(speed, 0);
      } else {
        next.config.velocity.set(speed, 0);
      }
      rotatePoint(next.rotation, next.config.velocity);
      next = next.next;
    }
  }
  updateParticle(particle, deltaSec) {
    const vel = particle.config.velocity;
    const oldVX = vel.x;
    const oldVY = vel.y;
    vel.x += this.accel.x * deltaSec;
    vel.y += this.accel.y * deltaSec;
    if (this.maxSpeed) {
      const currentSpeed = length(vel);
      if (currentSpeed > this.maxSpeed) {
        scaleBy(vel, this.maxSpeed / currentSpeed);
      }
    }
    particle.x += (oldVX + vel.x) / 2 * deltaSec;
    particle.y += (oldVY + vel.y) / 2 * deltaSec;
    if (this.rotate) {
      particle.rotation = Math.atan2(vel.y, vel.x);
    }
  }
};
AccelerationBehavior.type = "moveAcceleration";
AccelerationBehavior.editorConfig = null;
function intValueSimple(lerp) {
  if (this.ease)
    lerp = this.ease(lerp);
  return (this.first.next.value - this.first.value) * lerp + this.first.value;
}
function intColorSimple(lerp) {
  if (this.ease)
    lerp = this.ease(lerp);
  const curVal = this.first.value;
  const nextVal = this.first.next.value;
  const r = (nextVal.r - curVal.r) * lerp + curVal.r;
  const g = (nextVal.g - curVal.g) * lerp + curVal.g;
  const b = (nextVal.b - curVal.b) * lerp + curVal.b;
  return combineRGBComponents(r, g, b);
}
function intValueComplex(lerp) {
  if (this.ease)
    lerp = this.ease(lerp);
  let current = this.first;
  let next = current.next;
  while (lerp > next.time) {
    current = next;
    next = next.next;
  }
  lerp = (lerp - current.time) / (next.time - current.time);
  return (next.value - current.value) * lerp + current.value;
}
function intColorComplex(lerp) {
  if (this.ease)
    lerp = this.ease(lerp);
  let current = this.first;
  let next = current.next;
  while (lerp > next.time) {
    current = next;
    next = next.next;
  }
  lerp = (lerp - current.time) / (next.time - current.time);
  const curVal = current.value;
  const nextVal = next.value;
  const r = (nextVal.r - curVal.r) * lerp + curVal.r;
  const g = (nextVal.g - curVal.g) * lerp + curVal.g;
  const b = (nextVal.b - curVal.b) * lerp + curVal.b;
  return combineRGBComponents(r, g, b);
}
function intValueStepped(lerp) {
  if (this.ease)
    lerp = this.ease(lerp);
  let current = this.first;
  while (current.next && lerp > current.next.time) {
    current = current.next;
  }
  return current.value;
}
function intColorStepped(lerp) {
  if (this.ease)
    lerp = this.ease(lerp);
  let current = this.first;
  while (current.next && lerp > current.next.time) {
    current = current.next;
  }
  const curVal = current.value;
  return combineRGBComponents(curVal.r, curVal.g, curVal.b);
}
var PropertyList = class {
  /**
   * @param isColor If this list handles color values
   */
  constructor(isColor = false) {
    this.first = null;
    this.isColor = !!isColor;
    this.interpolate = null;
    this.ease = null;
  }
  /**
   * Resets the list for use.
   * @param first The first node in the list.
   * @param first.isStepped If the values should be stepped instead of interpolated linearly.
   */
  reset(first) {
    this.first = first;
    const isSimple = first.next && first.next.time >= 1;
    if (isSimple) {
      this.interpolate = this.isColor ? intColorSimple : intValueSimple;
    } else if (first.isStepped) {
      this.interpolate = this.isColor ? intColorStepped : intValueStepped;
    } else {
      this.interpolate = this.isColor ? intColorComplex : intValueComplex;
    }
    this.ease = this.first.ease;
  }
};
var AlphaBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    this.list = new PropertyList(false);
    this.list.reset(PropertyNode.createList(config.alpha));
  }
  initParticles(first) {
    let next = first;
    while (next) {
      next.alpha = this.list.first.value;
      next = next.next;
    }
  }
  updateParticle(particle) {
    particle.alpha = this.list.interpolate(particle.agePercent);
  }
};
AlphaBehavior.type = "alpha";
AlphaBehavior.editorConfig = null;
var StaticAlphaBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    this.value = config.alpha;
  }
  initParticles(first) {
    let next = first;
    while (next) {
      next.alpha = this.value;
      next = next.next;
    }
  }
};
StaticAlphaBehavior.type = "alphaStatic";
StaticAlphaBehavior.editorConfig = null;
function getTextures(textures) {
  const outTextures = [];
  for (let j = 0; j < textures.length; ++j) {
    let tex = textures[j];
    if (typeof tex === "string") {
      outTextures.push(GetTextureFromString(tex));
    } else if (tex instanceof Texture) {
      outTextures.push(tex);
    } else {
      let dupe = tex.count || 1;
      if (typeof tex.texture === "string") {
        tex = GetTextureFromString(tex.texture);
      } else {
        tex = tex.texture;
      }
      for (; dupe > 0; --dupe) {
        outTextures.push(tex);
      }
    }
  }
  return outTextures;
}
var RandomAnimatedTextureBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    this.anims = [];
    for (let i = 0; i < config.anims.length; ++i) {
      const anim = config.anims[i];
      const textures = getTextures(anim.textures);
      const framerate = anim.framerate < 0 ? -1 : anim.framerate > 0 ? anim.framerate : 60;
      const parsedAnim = {
        textures,
        duration: framerate > 0 ? textures.length / framerate : 0,
        framerate,
        loop: framerate > 0 ? !!anim.loop : false
      };
      this.anims.push(parsedAnim);
    }
  }
  initParticles(first) {
    let next = first;
    while (next) {
      const index = Math.floor(Math.random() * this.anims.length);
      const anim = next.config.anim = this.anims[index];
      next.texture = anim.textures[0];
      next.config.animElapsed = 0;
      if (anim.framerate === -1) {
        next.config.animDuration = next.maxLife;
        next.config.animFramerate = anim.textures.length / next.maxLife;
      } else {
        next.config.animDuration = anim.duration;
        next.config.animFramerate = anim.framerate;
      }
      next = next.next;
    }
  }
  updateParticle(particle, deltaSec) {
    const config = particle.config;
    const anim = config.anim;
    config.animElapsed += deltaSec;
    if (config.animElapsed >= config.animDuration) {
      if (config.anim.loop) {
        config.animElapsed = config.animElapsed % config.animDuration;
      } else {
        config.animElapsed = config.animDuration - 1e-6;
      }
    }
    const frame = config.animElapsed * config.animFramerate + 1e-7 | 0;
    particle.texture = anim.textures[frame] || anim.textures[anim.textures.length - 1] || Texture.EMPTY;
  }
};
RandomAnimatedTextureBehavior.type = "animatedRandom";
RandomAnimatedTextureBehavior.editorConfig = null;
var SingleAnimatedTextureBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    const anim = config.anim;
    const textures = getTextures(anim.textures);
    const framerate = anim.framerate < 0 ? -1 : anim.framerate > 0 ? anim.framerate : 60;
    this.anim = {
      textures,
      duration: framerate > 0 ? textures.length / framerate : 0,
      framerate,
      loop: framerate > 0 ? !!anim.loop : false
    };
  }
  initParticles(first) {
    let next = first;
    const anim = this.anim;
    while (next) {
      next.texture = anim.textures[0];
      next.config.animElapsed = 0;
      if (anim.framerate === -1) {
        next.config.animDuration = next.maxLife;
        next.config.animFramerate = anim.textures.length / next.maxLife;
      } else {
        next.config.animDuration = anim.duration;
        next.config.animFramerate = anim.framerate;
      }
      next = next.next;
    }
  }
  updateParticle(particle, deltaSec) {
    const anim = this.anim;
    const config = particle.config;
    config.animElapsed += deltaSec;
    if (config.animElapsed >= config.animDuration) {
      if (anim.loop) {
        config.animElapsed = config.animElapsed % config.animDuration;
      } else {
        config.animElapsed = config.animDuration - 1e-6;
      }
    }
    const frame = config.animElapsed * config.animFramerate + 1e-7 | 0;
    particle.texture = anim.textures[frame] || anim.textures[anim.textures.length - 1] || Texture.EMPTY;
  }
};
SingleAnimatedTextureBehavior.type = "animatedSingle";
SingleAnimatedTextureBehavior.editorConfig = null;
var BlendModeBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    this.value = config.blendMode;
  }
  initParticles(first) {
    let next = first;
    while (next) {
      next.blendMode = getBlendMode(this.value);
      next = next.next;
    }
  }
};
BlendModeBehavior.type = "blendMode";
BlendModeBehavior.editorConfig = null;
var BurstSpawnBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Spawn;
    this.spacing = config.spacing * DEG_TO_RADS;
    this.start = config.start * DEG_TO_RADS;
    this.distance = config.distance;
  }
  initParticles(first) {
    let count = 0;
    let next = first;
    while (next) {
      let angle;
      if (this.spacing) {
        angle = this.start + this.spacing * count;
      } else {
        angle = Math.random() * Math.PI * 2;
      }
      next.rotation = angle;
      if (this.distance) {
        next.position.x = this.distance;
        rotatePoint(angle, next.position);
      }
      next = next.next;
      ++count;
    }
  }
};
BurstSpawnBehavior.type = "spawnBurst";
BurstSpawnBehavior.editorConfig = null;
var ColorBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    this.list = new PropertyList(true);
    this.list.reset(PropertyNode.createList(config.color));
  }
  initParticles(first) {
    let next = first;
    const color = this.list.first.value;
    const tint = combineRGBComponents(color.r, color.g, color.b);
    while (next) {
      next.tint = tint;
      next = next.next;
    }
  }
  updateParticle(particle) {
    particle.tint = this.list.interpolate(particle.agePercent);
  }
};
ColorBehavior.type = "color";
ColorBehavior.editorConfig = null;
var StaticColorBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    let color = config.color;
    if (color.charAt(0) === "#") {
      color = color.substr(1);
    } else if (color.indexOf("0x") === 0) {
      color = color.substr(2);
    }
    this.value = parseInt(color, 16);
  }
  initParticles(first) {
    let next = first;
    while (next) {
      next.tint = this.value;
      next = next.next;
    }
  }
};
StaticColorBehavior.type = "colorStatic";
StaticColorBehavior.editorConfig = null;
var OrderedTextureBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    this.index = 0;
    this.textures = config.textures.map((tex) => typeof tex === "string" ? GetTextureFromString(tex) : tex);
  }
  initParticles(first) {
    let next = first;
    while (next) {
      next.texture = this.textures[this.index];
      if (++this.index >= this.textures.length) {
        this.index = 0;
      }
      next = next.next;
    }
  }
};
OrderedTextureBehavior.type = "textureOrdered";
OrderedTextureBehavior.editorConfig = null;
var helperPoint = new Point();
var MATH_FUNCS = [
  "E",
  "LN2",
  "LN10",
  "LOG2E",
  "LOG10E",
  "PI",
  "SQRT1_2",
  "SQRT2",
  "abs",
  "acos",
  "acosh",
  "asin",
  "asinh",
  "atan",
  "atanh",
  "atan2",
  "cbrt",
  "ceil",
  "cos",
  "cosh",
  "exp",
  "expm1",
  "floor",
  "fround",
  "hypot",
  "log",
  "log1p",
  "log10",
  "log2",
  "max",
  "min",
  "pow",
  "random",
  "round",
  "sign",
  "sin",
  "sinh",
  "sqrt",
  "tan",
  "tanh"
];
var WHITELISTER = new RegExp([
  // Allow the 4 basic operations, parentheses and all numbers/decimals, as well
  // as 'x', for the variable usage.
  "[01234567890\\.\\*\\-\\+\\/\\(\\)x ,]"
].concat(MATH_FUNCS).join("|"), "g");
function parsePath(pathString) {
  const matches = pathString.match(WHITELISTER);
  for (let i = matches.length - 1; i >= 0; --i) {
    if (MATH_FUNCS.indexOf(matches[i]) >= 0) {
      matches[i] = `Math.${matches[i]}`;
    }
  }
  pathString = matches.join("");
  return new Function("x", `return ${pathString};`);
}
var PathBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Late;
    if (config.path) {
      if (typeof config.path === "function") {
        this.path = config.path;
      } else {
        try {
          this.path = parsePath(config.path);
        } catch (e) {
          this.path = null;
        }
      }
    } else {
      this.path = (x) => x;
    }
    this.list = new PropertyList(false);
    this.list.reset(PropertyNode.createList(config.speed));
    this.minMult = config.minMult ?? 1;
  }
  initParticles(first) {
    let next = first;
    while (next) {
      next.config.initRotation = next.rotation;
      if (!next.config.initPosition) {
        next.config.initPosition = new Point(next.x, next.y);
      } else {
        next.config.initPosition.copyFrom(next.position);
      }
      next.config.movement = 0;
      const mult = Math.random() * (1 - this.minMult) + this.minMult;
      next.config.speedMult = mult;
      next = next.next;
    }
  }
  updateParticle(particle, deltaSec) {
    const speed = this.list.interpolate(particle.agePercent) * particle.config.speedMult;
    particle.config.movement += speed * deltaSec;
    helperPoint.x = particle.config.movement;
    helperPoint.y = this.path(helperPoint.x);
    rotatePoint(particle.config.initRotation, helperPoint);
    particle.position.x = particle.config.initPosition.x + helperPoint.x;
    particle.position.y = particle.config.initPosition.y + helperPoint.y;
  }
};
PathBehavior.type = "movePath";
PathBehavior.editorConfig = null;
var PointSpawnBehavior = class {
  constructor() {
    this.order = BehaviorOrder.Spawn;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  initParticles(_first) {
  }
};
PointSpawnBehavior.type = "spawnPoint";
PointSpawnBehavior.editorConfig = null;
var RandomTextureBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    this.textures = config.textures.map((tex) => typeof tex === "string" ? GetTextureFromString(tex) : tex);
  }
  initParticles(first) {
    let next = first;
    while (next) {
      const index = Math.floor(Math.random() * this.textures.length);
      next.texture = this.textures[index];
      next = next.next;
    }
  }
};
RandomTextureBehavior.type = "textureRandom";
RandomTextureBehavior.editorConfig = null;
var RotationBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    this.minStart = config.minStart * DEG_TO_RADS;
    this.maxStart = config.maxStart * DEG_TO_RADS;
    this.minSpeed = config.minSpeed * DEG_TO_RADS;
    this.maxSpeed = config.maxSpeed * DEG_TO_RADS;
    this.accel = config.accel * DEG_TO_RADS;
  }
  initParticles(first) {
    let next = first;
    while (next) {
      if (this.minStart === this.maxStart) {
        next.rotation += this.maxStart;
      } else {
        next.rotation += Math.random() * (this.maxStart - this.minStart) + this.minStart;
      }
      next.config.rotSpeed = Math.random() * (this.maxSpeed - this.minSpeed) + this.minSpeed;
      next = next.next;
    }
  }
  updateParticle(particle, deltaSec) {
    if (this.accel) {
      const oldSpeed = particle.config.rotSpeed;
      particle.config.rotSpeed += this.accel * deltaSec;
      particle.rotation += (particle.config.rotSpeed + oldSpeed) / 2 * deltaSec;
    } else {
      particle.rotation += particle.config.rotSpeed * deltaSec;
    }
  }
};
RotationBehavior.type = "rotation";
RotationBehavior.editorConfig = null;
var StaticRotationBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    this.min = config.min * DEG_TO_RADS;
    this.max = config.max * DEG_TO_RADS;
  }
  initParticles(first) {
    let next = first;
    while (next) {
      if (this.min === this.max) {
        next.rotation += this.max;
      } else {
        next.rotation += Math.random() * (this.max - this.min) + this.min;
      }
      next = next.next;
    }
  }
};
StaticRotationBehavior.type = "rotationStatic";
StaticRotationBehavior.editorConfig = null;
var NoRotationBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Late + 1;
    this.rotation = (config.rotation || 0) * DEG_TO_RADS;
  }
  initParticles(first) {
    let next = first;
    while (next) {
      next.rotation = this.rotation;
      next = next.next;
    }
  }
};
NoRotationBehavior.type = "noRotation";
NoRotationBehavior.editorConfig = null;
var ScaleBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    this.list = new PropertyList(false);
    this.list.reset(PropertyNode.createList(config.scale));
    this.minMult = config.minMult ?? 1;
  }
  initParticles(first) {
    let next = first;
    while (next) {
      const mult = Math.random() * (1 - this.minMult) + this.minMult;
      next.config.scaleMult = mult;
      next.scale.x = next.scale.y = this.list.first.value * mult;
      next = next.next;
    }
  }
  updateParticle(particle) {
    particle.scale.x = particle.scale.y = this.list.interpolate(particle.agePercent) * particle.config.scaleMult;
  }
};
ScaleBehavior.type = "scale";
ScaleBehavior.editorConfig = null;
var StaticScaleBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    this.min = config.min;
    this.max = config.max;
  }
  initParticles(first) {
    let next = first;
    while (next) {
      const scale = Math.random() * (this.max - this.min) + this.min;
      next.scale.x = next.scale.y = scale;
      next = next.next;
    }
  }
};
StaticScaleBehavior.type = "scaleStatic";
StaticScaleBehavior.editorConfig = null;
var ShapeSpawnBehavior = class _ShapeSpawnBehavior {
  /**
   * Registers a shape to be used by the ShapeSpawn behavior.
   * @param constructor The shape class constructor to use, with a static `type` property to reference it by.
   * @param typeOverride An optional type override, primarily for registering a shape under multiple names.
   */
  static registerShape(constructor, typeOverride) {
    _ShapeSpawnBehavior.shapes[typeOverride || constructor.type] = constructor;
  }
  constructor(config) {
    this.order = BehaviorOrder.Spawn;
    const ShapeClass = _ShapeSpawnBehavior.shapes[config.type];
    if (!ShapeClass) {
      throw new Error(`No shape found with type '${config.type}'`);
    }
    this.shape = new ShapeClass(config.data);
  }
  initParticles(first) {
    let next = first;
    while (next) {
      this.shape.getRandPos(next);
      next = next.next;
    }
  }
};
ShapeSpawnBehavior.type = "spawnShape";
ShapeSpawnBehavior.editorConfig = null;
ShapeSpawnBehavior.shapes = {};
ShapeSpawnBehavior.registerShape(PolygonalChain);
ShapeSpawnBehavior.registerShape(Rectangle);
ShapeSpawnBehavior.registerShape(Torus);
ShapeSpawnBehavior.registerShape(Torus, "circle");
var SingleTextureBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Normal;
    this.texture = typeof config.texture === "string" ? GetTextureFromString(config.texture) : config.texture;
  }
  initParticles(first) {
    let next = first;
    while (next) {
      next.texture = this.texture;
      next = next.next;
    }
  }
};
SingleTextureBehavior.type = "textureSingle";
SingleTextureBehavior.editorConfig = null;
var SpeedBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Late;
    this.list = new PropertyList(false);
    this.list.reset(PropertyNode.createList(config.speed));
    this.minMult = config.minMult ?? 1;
  }
  initParticles(first) {
    let next = first;
    while (next) {
      const mult = Math.random() * (1 - this.minMult) + this.minMult;
      next.config.speedMult = mult;
      if (!next.config.velocity) {
        next.config.velocity = new Point(this.list.first.value * mult, 0);
      } else {
        next.config.velocity.set(this.list.first.value * mult, 0);
      }
      rotatePoint(next.rotation, next.config.velocity);
      next = next.next;
    }
  }
  updateParticle(particle, deltaSec) {
    const speed = this.list.interpolate(particle.agePercent) * particle.config.speedMult;
    const vel = particle.config.velocity;
    normalize(vel);
    scaleBy(vel, speed);
    particle.x += vel.x * deltaSec;
    particle.y += vel.y * deltaSec;
  }
};
SpeedBehavior.type = "moveSpeed";
SpeedBehavior.editorConfig = null;
var StaticSpeedBehavior = class {
  constructor(config) {
    this.order = BehaviorOrder.Late;
    this.min = config.min;
    this.max = config.max;
  }
  initParticles(first) {
    let next = first;
    while (next) {
      const speed = Math.random() * (this.max - this.min) + this.min;
      if (!next.config.velocity) {
        next.config.velocity = new Point(speed, 0);
      } else {
        next.config.velocity.set(speed, 0);
      }
      rotatePoint(next.rotation, next.config.velocity);
      next = next.next;
    }
  }
  updateParticle(particle, deltaSec) {
    const velocity = particle.config.velocity;
    particle.x += velocity.x * deltaSec;
    particle.y += velocity.y * deltaSec;
  }
};
StaticSpeedBehavior.type = "moveSpeedStatic";
StaticSpeedBehavior.editorConfig = null;
var Particle = class extends Sprite {
  /**
   * @param emitter The emitter that controls this particle.
   */
  constructor(emitter) {
    super();
    this.prevChild = this.nextChild = null;
    this.emitter = emitter;
    this.config = {};
    this.anchor.x = this.anchor.y = 0.5;
    this.maxLife = 0;
    this.age = 0;
    this.agePercent = 0;
    this.oneOverLife = 0;
    this.next = null;
    this.prev = null;
    this.init = this.init;
    this.kill = this.kill;
  }
  /**
   * Initializes the particle for use, based on the properties that have to
   * have been set already on the particle.
   */
  init(maxLife) {
    this.maxLife = maxLife;
    this.age = this.agePercent = 0;
    this.rotation = 0;
    this.position.x = this.position.y = 0;
    this.scale.x = this.scale.y = 1;
    this.tint = 16777215;
    this.alpha = 1;
    this.oneOverLife = 1 / this.maxLife;
    this.visible = true;
  }
  /**
   * Kills the particle, removing it from the display list
   * and telling the emitter to recycle it.
   */
  kill() {
    this.emitter.recycle(this);
  }
  /**
   * Destroys the particle, removing references and preventing future use.
   */
  destroy() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
    this.emitter = this.next = this.prev = null;
    super.destroy();
  }
};
var ticker = Ticker.shared;
var PositionParticle = Symbol("Position particle per emitter position");
var Emitter = class _Emitter {
  /**
   * Registers a new behavior, so that it will be recognized when initializing emitters.
   * Behaviors registered later with duplicate types will override older ones, although there is no limit on
   * the allowed types.
   * @param constructor The behavior class to register.
   */
  static registerBehavior(constructor) {
    _Emitter.knownBehaviors[constructor.type] = constructor;
  }
  /**
   * @param particleParent The container to add the particles to.
   * @param particleImages A texture or array of textures to use
   *                       for the particles. Strings will be turned
   *                       into textures via Texture.from().
   * @param config A configuration object containing settings for the emitter.
   * @param config.emit If config.emit is explicitly passed as false, the
   *                    Emitter will start disabled.
   * @param config.autoUpdate If config.autoUpdate is explicitly passed as
   *                          true, the Emitter will automatically call
   *                          update via the PIXI shared ticker.
   */
  constructor(particleParent, config) {
    this.initBehaviors = [];
    this.updateBehaviors = [];
    this.recycleBehaviors = [];
    this.minLifetime = 0;
    this.maxLifetime = 0;
    this.customEase = null;
    this._frequency = 1;
    this.spawnChance = 1;
    this.maxParticles = 1e3;
    this.emitterLifetime = -1;
    this.spawnPos = new Point();
    this.particlesPerWave = 1;
    this.rotation = 0;
    this.ownerPos = new Point();
    this._prevEmitterPos = new Point();
    this._prevPosIsValid = false;
    this._posChanged = false;
    this._parent = null;
    this.addAtBack = false;
    this.particleCount = 0;
    this._emit = false;
    this._spawnTimer = 0;
    this._emitterLife = -1;
    this._activeParticlesFirst = null;
    this._activeParticlesLast = null;
    this._poolFirst = null;
    this._origConfig = null;
    this._autoUpdate = false;
    this._destroyWhenComplete = false;
    this._completeCallback = null;
    this.parent = particleParent;
    if (config) {
      this.init(config);
    }
    this.recycle = this.recycle;
    this.update = this.update;
    this.rotate = this.rotate;
    this.updateSpawnPos = this.updateSpawnPos;
    this.updateOwnerPos = this.updateOwnerPos;
  }
  /**
   * Time between particle spawns in seconds. If this value is not a number greater than 0,
   * it will be set to 1 (particle per second) to prevent infinite loops.
   */
  get frequency() {
    return this._frequency;
  }
  set frequency(value) {
    if (typeof value === "number" && value > 0) {
      this._frequency = value;
    } else {
      this._frequency = 1;
    }
  }
  /**
  * The container to add particles to. Settings this will dump any active particles.
  */
  get parent() {
    return this._parent;
  }
  set parent(value) {
    this.cleanup();
    this._parent = value;
  }
  /**
   * Sets up the emitter based on the config settings.
   * @param config A configuration object containing settings for the emitter.
   */
  init(config) {
    if (!config) {
      return;
    }
    this.cleanup();
    this._origConfig = config;
    this.minLifetime = config.lifetime.min;
    this.maxLifetime = config.lifetime.max;
    if (config.ease) {
      this.customEase = typeof config.ease === "function" ? config.ease : generateEase(config.ease);
    } else {
      this.customEase = null;
    }
    this.particlesPerWave = 1;
    if (config.particlesPerWave && config.particlesPerWave > 1) {
      this.particlesPerWave = config.particlesPerWave;
    }
    this.frequency = config.frequency;
    this.spawnChance = typeof config.spawnChance === "number" && config.spawnChance > 0 ? config.spawnChance : 1;
    this.emitterLifetime = config.emitterLifetime || -1;
    this.maxParticles = config.maxParticles > 0 ? config.maxParticles : 1e3;
    this.addAtBack = !!config.addAtBack;
    this.rotation = 0;
    this.ownerPos.set(0);
    if (config.pos) {
      this.spawnPos.copyFrom(config.pos);
    } else {
      this.spawnPos.set(0);
    }
    this._prevEmitterPos.copyFrom(this.spawnPos);
    this._prevPosIsValid = false;
    this._spawnTimer = 0;
    this.emit = config.emit === void 0 ? true : !!config.emit;
    this.autoUpdate = !!config.autoUpdate;
    const behaviors = config.behaviors.map((data) => {
      const constructor = _Emitter.knownBehaviors[data.type];
      if (!constructor) {
        console.error(`Unknown behavior: ${data.type}`);
        return null;
      }
      return new constructor(data.config);
    }).filter((b) => !!b);
    behaviors.push(PositionParticle);
    behaviors.sort((a, b) => {
      if (a === PositionParticle) {
        return b.order === BehaviorOrder.Spawn ? 1 : -1;
      } else if (b === PositionParticle) {
        return a.order === BehaviorOrder.Spawn ? -1 : 1;
      }
      return a.order - b.order;
    });
    this.initBehaviors = behaviors.slice();
    this.updateBehaviors = behaviors.filter((b) => b !== PositionParticle && b.updateParticle);
    this.recycleBehaviors = behaviors.filter((b) => b !== PositionParticle && b.recycleParticle);
  }
  /**
   * Gets the instantiated behavior of the specified type, if it is present on this emitter.
   * @param type The behavior type to find.
   */
  getBehavior(type) {
    if (!_Emitter.knownBehaviors[type])
      return null;
    return this.initBehaviors.find((b) => b instanceof _Emitter.knownBehaviors[type]) || null;
  }
  /**
   * Fills the pool with the specified number of particles, so that they don't have to be instantiated later.
   * @param count The number of particles to create.
   */
  fillPool(count) {
    for (; count > 0; --count) {
      const p = new Particle(this);
      p.next = this._poolFirst;
      this._poolFirst = p;
    }
  }
  /**
   * Recycles an individual particle. For internal use only.
   * @param particle The particle to recycle.
   * @param fromCleanup If this is being called to manually clean up all particles.
   * @internal
   */
  recycle(particle, fromCleanup = false) {
    for (let i = 0; i < this.recycleBehaviors.length; ++i) {
      this.recycleBehaviors[i].recycleParticle(particle, !fromCleanup);
    }
    if (particle.next) {
      particle.next.prev = particle.prev;
    }
    if (particle.prev) {
      particle.prev.next = particle.next;
    }
    if (particle === this._activeParticlesLast) {
      this._activeParticlesLast = particle.prev;
    }
    if (particle === this._activeParticlesFirst) {
      this._activeParticlesFirst = particle.next;
    }
    particle.prev = null;
    particle.next = this._poolFirst;
    this._poolFirst = particle;
    if (particle.parent) {
      particle.parent.removeChild(particle);
    }
    --this.particleCount;
  }
  /**
   * Sets the rotation of the emitter to a new value. This rotates the spawn position in addition
   * to particle direction.
   * @param newRot The new rotation, in degrees.
   */
  rotate(newRot) {
    if (this.rotation === newRot)
      return;
    const diff = newRot - this.rotation;
    this.rotation = newRot;
    rotatePoint(diff, this.spawnPos);
    this._posChanged = true;
  }
  /**
   * Changes the spawn position of the emitter.
   * @param x The new x value of the spawn position for the emitter.
   * @param y The new y value of the spawn position for the emitter.
   */
  updateSpawnPos(x, y) {
    this._posChanged = true;
    this.spawnPos.x = x;
    this.spawnPos.y = y;
  }
  /**
   * Changes the position of the emitter's owner. You should call this if you are adding
   * particles to the world container that your emitter's owner is moving around in.
   * @param x The new x value of the emitter's owner.
   * @param y The new y value of the emitter's owner.
   */
  updateOwnerPos(x, y) {
    this._posChanged = true;
    this.ownerPos.x = x;
    this.ownerPos.y = y;
  }
  /**
   * Prevents emitter position interpolation in the next update.
   * This should be used if you made a major position change of your emitter's owner
   * that was not normal movement.
   */
  resetPositionTracking() {
    this._prevPosIsValid = false;
  }
  /**
   * If particles should be emitted during update() calls. Setting this to false
   * stops new particles from being created, but allows existing ones to die out.
   */
  get emit() {
    return this._emit;
  }
  set emit(value) {
    this._emit = !!value;
    this._emitterLife = this.emitterLifetime;
  }
  /**
   * If the update function is called automatically from the shared ticker.
   * Setting this to false requires calling the update function manually.
   */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (this._autoUpdate && !value) {
      ticker.remove(this.update, this);
    } else if (!this._autoUpdate && value) {
      ticker.add(this.update, this);
    }
    this._autoUpdate = !!value;
  }
  /**
   * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself
   * when particle emission is complete.
   * @param callback Callback for when emission is complete (all particles have died off)
   */
  playOnceAndDestroy(callback) {
    this.autoUpdate = true;
    this.emit = true;
    this._destroyWhenComplete = true;
    this._completeCallback = callback;
  }
  /**
   * Starts emitting particles and optionally calls a callback when particle emission is complete.
   * @param callback Callback for when emission is complete (all particles have died off)
   */
  playOnce(callback) {
    this.emit = true;
    this._completeCallback = callback;
  }
  /**
   * Updates all particles spawned by this emitter and emits new ones.
   * @param delta Time elapsed since the previous frame, in __seconds__. Or Ticker instance for pixi.js v8.0.0
   */
  update(delta) {
    if (typeof delta !== "number") {
      delta = delta.deltaTime;
    }
    if (this._autoUpdate) {
      delta = ticker.elapsedMS * 1e-3;
    }
    if (!this._parent)
      return;
    for (let particle = this._activeParticlesFirst, next; particle; particle = next) {
      next = particle.next;
      particle.age += delta;
      if (particle.age > particle.maxLife || particle.age < 0) {
        this.recycle(particle);
      } else {
        let lerp = particle.age * particle.oneOverLife;
        if (this.customEase) {
          if (this.customEase.length === 4) {
            lerp = this.customEase(lerp, 0, 1, 1);
          } else {
            lerp = this.customEase(lerp);
          }
        }
        particle.agePercent = lerp;
        for (let i = 0; i < this.updateBehaviors.length; ++i) {
          if (this.updateBehaviors[i].updateParticle(particle, delta)) {
            this.recycle(particle);
            break;
          }
        }
      }
    }
    let prevX;
    let prevY;
    if (this._prevPosIsValid) {
      prevX = this._prevEmitterPos.x;
      prevY = this._prevEmitterPos.y;
    }
    const curX = this.ownerPos.x + this.spawnPos.x;
    const curY = this.ownerPos.y + this.spawnPos.y;
    if (this._emit) {
      this._spawnTimer -= delta < 0 ? 0 : delta;
      while (this._spawnTimer <= 0) {
        if (this._emitterLife >= 0) {
          this._emitterLife -= this._frequency;
          if (this._emitterLife <= 0) {
            this._spawnTimer = 0;
            this._emitterLife = 0;
            this.emit = false;
            break;
          }
        }
        if (this.particleCount >= this.maxParticles) {
          this._spawnTimer += this._frequency;
          continue;
        }
        let emitPosX;
        let emitPosY;
        if (this._prevPosIsValid && this._posChanged) {
          const lerp = 1 + this._spawnTimer / delta;
          emitPosX = (curX - prevX) * lerp + prevX;
          emitPosY = (curY - prevY) * lerp + prevY;
        } else {
          emitPosX = curX;
          emitPosY = curY;
        }
        let waveFirst = null;
        let waveLast = null;
        for (let len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), i = 0; i < len; ++i) {
          if (this.spawnChance < 1 && Math.random() >= this.spawnChance) {
            continue;
          }
          let lifetime;
          if (this.minLifetime === this.maxLifetime) {
            lifetime = this.minLifetime;
          } else {
            lifetime = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime;
          }
          if (-this._spawnTimer >= lifetime) {
            continue;
          }
          let p;
          if (this._poolFirst) {
            p = this._poolFirst;
            this._poolFirst = this._poolFirst.next;
            p.next = null;
          } else {
            p = new Particle(this);
          }
          p.init(lifetime);
          if (this.addAtBack) {
            this._parent.addChildAt(p, 0);
          } else {
            this._parent.addChild(p);
          }
          if (waveFirst) {
            waveLast.next = p;
            p.prev = waveLast;
            waveLast = p;
          } else {
            waveLast = waveFirst = p;
          }
          ++this.particleCount;
        }
        if (waveFirst) {
          if (this._activeParticlesLast) {
            this._activeParticlesLast.next = waveFirst;
            waveFirst.prev = this._activeParticlesLast;
            this._activeParticlesLast = waveLast;
          } else {
            this._activeParticlesFirst = waveFirst;
            this._activeParticlesLast = waveLast;
          }
          for (let i = 0; i < this.initBehaviors.length; ++i) {
            const behavior = this.initBehaviors[i];
            if (behavior === PositionParticle) {
              for (let particle = waveFirst, next; particle; particle = next) {
                next = particle.next;
                if (this.rotation !== 0) {
                  rotatePoint(this.rotation, particle.position);
                  particle.rotation += this.rotation;
                }
                particle.position.x += emitPosX;
                particle.position.y += emitPosY;
                particle.age += -this._spawnTimer;
                let lerp = particle.age * particle.oneOverLife;
                if (this.customEase) {
                  if (this.customEase.length === 4) {
                    lerp = this.customEase(lerp, 0, 1, 1);
                  } else {
                    lerp = this.customEase(lerp);
                  }
                }
                particle.agePercent = lerp;
              }
            } else {
              behavior.initParticles(waveFirst);
            }
          }
          for (let particle = waveFirst, next; particle; particle = next) {
            next = particle.next;
            for (let i = 0; i < this.updateBehaviors.length; ++i) {
              if (this.updateBehaviors[i].updateParticle(particle, -this._spawnTimer)) {
                this.recycle(particle);
                break;
              }
            }
          }
        }
        this._spawnTimer += this._frequency;
      }
    }
    if (this._posChanged) {
      this._prevEmitterPos.x = curX;
      this._prevEmitterPos.y = curY;
      this._prevPosIsValid = true;
      this._posChanged = false;
    }
    if (!this._emit && !this._activeParticlesFirst) {
      if (this._completeCallback) {
        const cb = this._completeCallback;
        this._completeCallback = null;
        cb();
      }
      if (this._destroyWhenComplete) {
        this.destroy();
      }
    }
  }
  /**
   * Emits a single wave of particles, using standard spawnChance & particlesPerWave settings. Does not affect
   * regular spawning through the frequency, and ignores the emit property. The max particle count is respected, however,
   * so if there are already too many particles then nothing will happen.
   */
  emitNow() {
    const emitPosX = this.ownerPos.x + this.spawnPos.x;
    const emitPosY = this.ownerPos.y + this.spawnPos.y;
    let waveFirst = null;
    let waveLast = null;
    for (let len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), i = 0; i < len; ++i) {
      if (this.spawnChance < 1 && Math.random() >= this.spawnChance) {
        continue;
      }
      let p;
      if (this._poolFirst) {
        p = this._poolFirst;
        this._poolFirst = this._poolFirst.next;
        p.next = null;
      } else {
        p = new Particle(this);
      }
      let lifetime;
      if (this.minLifetime === this.maxLifetime) {
        lifetime = this.minLifetime;
      } else {
        lifetime = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime;
      }
      p.init(lifetime);
      if (this.addAtBack) {
        this._parent.addChildAt(p, 0);
      } else {
        this._parent.addChild(p);
      }
      if (waveFirst) {
        waveLast.next = p;
        p.prev = waveLast;
        waveLast = p;
      } else {
        waveLast = waveFirst = p;
      }
      ++this.particleCount;
    }
    if (waveFirst) {
      if (this._activeParticlesLast) {
        this._activeParticlesLast.next = waveFirst;
        waveFirst.prev = this._activeParticlesLast;
        this._activeParticlesLast = waveLast;
      } else {
        this._activeParticlesFirst = waveFirst;
        this._activeParticlesLast = waveLast;
      }
      for (let i = 0; i < this.initBehaviors.length; ++i) {
        const behavior = this.initBehaviors[i];
        if (behavior === PositionParticle) {
          for (let particle = waveFirst, next; particle; particle = next) {
            next = particle.next;
            if (this.rotation !== 0) {
              rotatePoint(this.rotation, particle.position);
              particle.rotation += this.rotation;
            }
            particle.position.x += emitPosX;
            particle.position.y += emitPosY;
          }
        } else {
          behavior.initParticles(waveFirst);
        }
      }
    }
  }
  /**
   * Kills all active particles immediately.
   */
  cleanup() {
    let particle;
    let next;
    for (particle = this._activeParticlesFirst; particle; particle = next) {
      next = particle.next;
      this.recycle(particle, true);
    }
    this._activeParticlesFirst = this._activeParticlesLast = null;
    this.particleCount = 0;
  }
  /**
   * If this emitter has been destroyed. Note that a destroyed emitter can still be reused, after
   * having a new parent set and being reinitialized.
   */
  get destroyed() {
    return !(this._parent && this.initBehaviors.length);
  }
  /**
   * Destroys the emitter and all of its particles.
   */
  destroy() {
    this.autoUpdate = false;
    this.cleanup();
    let next;
    for (let particle = this._poolFirst; particle; particle = next) {
      next = particle.next;
      particle.destroy();
    }
    this._poolFirst = this._parent = this.spawnPos = this.ownerPos = this.customEase = this._completeCallback = null;
    this.initBehaviors.length = this.updateBehaviors.length = this.recycleBehaviors.length = 0;
  }
};
Emitter.knownBehaviors = {};
function upgradeConfig(config, art) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  if ("behaviors" in config) {
    return config;
  }
  const out = {
    lifetime: config.lifetime,
    ease: config.ease,
    particlesPerWave: config.particlesPerWave,
    frequency: config.frequency,
    spawnChance: config.spawnChance,
    emitterLifetime: config.emitterLifetime,
    maxParticles: config.maxParticles,
    addAtBack: config.addAtBack,
    pos: config.pos,
    emit: config.emit,
    autoUpdate: config.autoUpdate,
    behaviors: []
  };
  if (config.alpha) {
    if ("start" in config.alpha) {
      if (config.alpha.start === config.alpha.end) {
        if (config.alpha.start !== 1) {
          out.behaviors.push({
            type: "alphaStatic",
            config: { alpha: config.alpha.start }
          });
        }
      } else {
        const list = {
          list: [
            { time: 0, value: config.alpha.start },
            { time: 1, value: config.alpha.end }
          ]
        };
        out.behaviors.push({
          type: "alpha",
          config: { alpha: list }
        });
      }
    } else if (config.alpha.list.length === 1) {
      if (config.alpha.list[0].value !== 1) {
        out.behaviors.push({
          type: "alphaStatic",
          config: { alpha: config.alpha.list[0].value }
        });
      }
    } else {
      out.behaviors.push({
        type: "alpha",
        config: { alpha: config.alpha }
      });
    }
  }
  if (config.acceleration && (config.acceleration.x || config.acceleration.y)) {
    let minStart;
    let maxStart;
    if ("start" in config.speed) {
      minStart = config.speed.start * (config.speed.minimumSpeedMultiplier ?? 1);
      maxStart = config.speed.start;
    } else {
      minStart = config.speed.list[0].value * (config.minimumSpeedMultiplier ?? 1);
      maxStart = config.speed.list[0].value;
    }
    out.behaviors.push({
      type: "moveAcceleration",
      config: {
        accel: config.acceleration,
        minStart,
        maxStart,
        rotate: !config.noRotation,
        maxSpeed: config.maxSpeed
      }
    });
  } else if ((_a = config.extraData) == null ? void 0 : _a.path) {
    let list;
    let mult;
    if ("start" in config.speed) {
      mult = config.speed.minimumSpeedMultiplier ?? 1;
      if (config.speed.start === config.speed.end) {
        list = {
          list: [{ time: 0, value: config.speed.start }]
        };
      } else {
        list = {
          list: [
            { time: 0, value: config.speed.start },
            { time: 1, value: config.speed.end }
          ]
        };
      }
    } else {
      list = config.speed;
      mult = config.minimumSpeedMultiplier ?? 1;
    }
    out.behaviors.push({
      type: "movePath",
      config: {
        path: config.extraData.path,
        speed: list,
        minMult: mult
      }
    });
  } else {
    if (config.speed) {
      if ("start" in config.speed) {
        if (config.speed.start === config.speed.end) {
          out.behaviors.push({
            type: "moveSpeedStatic",
            config: {
              min: config.speed.start * (config.speed.minimumSpeedMultiplier ?? 1),
              max: config.speed.start
            }
          });
        } else {
          const list = {
            list: [
              { time: 0, value: config.speed.start },
              { time: 1, value: config.speed.end }
            ]
          };
          out.behaviors.push({
            type: "moveSpeed",
            config: { speed: list, minMult: config.speed.minimumSpeedMultiplier }
          });
        }
      } else if (config.speed.list.length === 1) {
        out.behaviors.push({
          type: "moveSpeedStatic",
          config: {
            min: config.speed.list[0].value * (config.minimumSpeedMultiplier ?? 1),
            max: config.speed.list[0].value
          }
        });
      } else {
        out.behaviors.push({
          type: "moveSpeed",
          config: { speed: config.speed, minMult: config.minimumSpeedMultiplier ?? 1 }
        });
      }
    }
  }
  if (config.scale) {
    if ("start" in config.scale) {
      const mult = config.scale.minimumScaleMultiplier ?? 1;
      if (config.scale.start === config.scale.end) {
        out.behaviors.push({
          type: "scaleStatic",
          config: {
            min: config.scale.start * mult,
            max: config.scale.start
          }
        });
      } else {
        const list = {
          list: [
            { time: 0, value: config.scale.start },
            { time: 1, value: config.scale.end }
          ]
        };
        out.behaviors.push({
          type: "scale",
          config: { scale: list, minMult: mult }
        });
      }
    } else if (config.scale.list.length === 1) {
      const mult = config.minimumScaleMultiplier ?? 1;
      const scale = config.scale.list[0].value;
      out.behaviors.push({
        type: "scaleStatic",
        config: { min: scale * mult, max: scale }
      });
    } else {
      out.behaviors.push({
        type: "scale",
        config: { scale: config.scale, minMult: config.minimumScaleMultiplier ?? 1 }
      });
    }
  }
  if (config.color) {
    if ("start" in config.color) {
      if (config.color.start === config.color.end) {
        if (config.color.start !== "ffffff") {
          out.behaviors.push({
            type: "colorStatic",
            config: { color: config.color.start }
          });
        }
      } else {
        const list = {
          list: [
            { time: 0, value: config.color.start },
            { time: 1, value: config.color.end }
          ]
        };
        out.behaviors.push({
          type: "color",
          config: { color: list }
        });
      }
    } else if (config.color.list.length === 1) {
      if (config.color.list[0].value !== "ffffff") {
        out.behaviors.push({
          type: "colorStatic",
          config: { color: config.color.list[0].value }
        });
      }
    } else {
      out.behaviors.push({
        type: "color",
        config: { color: config.color }
      });
    }
  }
  if (config.rotationAcceleration || ((_b = config.rotationSpeed) == null ? void 0 : _b.min) || ((_c = config.rotationSpeed) == null ? void 0 : _c.max)) {
    out.behaviors.push({
      type: "rotation",
      config: {
        accel: config.rotationAcceleration || 0,
        minSpeed: ((_d = config.rotationSpeed) == null ? void 0 : _d.min) || 0,
        maxSpeed: ((_e = config.rotationSpeed) == null ? void 0 : _e.max) || 0,
        minStart: ((_f = config.startRotation) == null ? void 0 : _f.min) || 0,
        maxStart: ((_g = config.startRotation) == null ? void 0 : _g.max) || 0
      }
    });
  } else if (((_h = config.startRotation) == null ? void 0 : _h.min) || ((_i = config.startRotation) == null ? void 0 : _i.max)) {
    out.behaviors.push({
      type: "rotationStatic",
      config: {
        min: ((_j = config.startRotation) == null ? void 0 : _j.min) || 0,
        max: ((_k = config.startRotation) == null ? void 0 : _k.max) || 0
      }
    });
  }
  if (config.noRotation) {
    out.behaviors.push({
      type: "noRotation",
      config: {}
    });
  }
  if (config.blendMode && config.blendMode !== "normal") {
    out.behaviors.push({
      type: "blendMode",
      config: {
        blendMode: config.blendMode
      }
    });
  }
  if (Array.isArray(art) && typeof art[0] !== "string" && "framerate" in art[0]) {
    for (let i = 0; i < art.length; ++i) {
      if (art[i].framerate === "matchLife") {
        art[i].framerate = -1;
      }
    }
    out.behaviors.push({
      type: "animatedRandom",
      config: {
        anims: art
      }
    });
  } else if (typeof art !== "string" && "framerate" in art) {
    if (art.framerate === "matchLife") {
      art.framerate = -1;
    }
    out.behaviors.push({
      type: "animatedSingle",
      config: {
        anim: art
      }
    });
  } else if (config.orderedArt && Array.isArray(art)) {
    out.behaviors.push({
      type: "textureOrdered",
      config: {
        textures: art
      }
    });
  } else if (Array.isArray(art)) {
    out.behaviors.push({
      type: "textureRandom",
      config: {
        textures: art
      }
    });
  } else {
    out.behaviors.push({
      type: "textureSingle",
      config: {
        texture: art
      }
    });
  }
  if (config.spawnType === "burst") {
    out.behaviors.push({
      type: "spawnBurst",
      config: {
        start: config.angleStart || 0,
        spacing: config.particleSpacing,
        // older formats bursted from a single point
        distance: 0
      }
    });
  } else if (config.spawnType === "point") {
    out.behaviors.push({
      type: "spawnPoint",
      config: {}
    });
  } else {
    let shape;
    if (config.spawnType === "ring") {
      shape = {
        type: "torus",
        data: {
          x: config.spawnCircle.x,
          y: config.spawnCircle.y,
          radius: config.spawnCircle.r,
          innerRadius: config.spawnCircle.minR,
          affectRotation: true
        }
      };
    } else if (config.spawnType === "circle") {
      shape = {
        type: "torus",
        data: {
          x: config.spawnCircle.x,
          y: config.spawnCircle.y,
          radius: config.spawnCircle.r,
          innerRadius: 0,
          affectRotation: false
        }
      };
    } else if (config.spawnType === "rect") {
      shape = {
        type: "rect",
        data: config.spawnRect
      };
    } else if (config.spawnType === "polygonalChain") {
      shape = {
        type: "polygonalChain",
        data: config.spawnPolygon
      };
    }
    if (shape) {
      out.behaviors.push({
        type: "spawnShape",
        config: shape
      });
    }
  }
  return out;
}
Emitter.registerBehavior(AccelerationBehavior);
Emitter.registerBehavior(AlphaBehavior);
Emitter.registerBehavior(StaticAlphaBehavior);
Emitter.registerBehavior(RandomAnimatedTextureBehavior);
Emitter.registerBehavior(SingleAnimatedTextureBehavior);
Emitter.registerBehavior(BlendModeBehavior);
Emitter.registerBehavior(BurstSpawnBehavior);
Emitter.registerBehavior(ColorBehavior);
Emitter.registerBehavior(StaticColorBehavior);
Emitter.registerBehavior(OrderedTextureBehavior);
Emitter.registerBehavior(PathBehavior);
Emitter.registerBehavior(PointSpawnBehavior);
Emitter.registerBehavior(RandomTextureBehavior);
Emitter.registerBehavior(RotationBehavior);
Emitter.registerBehavior(StaticRotationBehavior);
Emitter.registerBehavior(NoRotationBehavior);
Emitter.registerBehavior(ScaleBehavior);
Emitter.registerBehavior(StaticScaleBehavior);
Emitter.registerBehavior(ShapeSpawnBehavior);
Emitter.registerBehavior(SingleTextureBehavior);
Emitter.registerBehavior(SpeedBehavior);
Emitter.registerBehavior(StaticSpeedBehavior);
export {
  Emitter,
  Particle,
  ParticleUtils,
  PropertyList,
  PropertyNode,
  upgradeConfig
};
/*! Bundled license information:

@barvynkoa/particle-emitter/lib/particle-emitter.es.js:
  (*!
   * @barvynkoa/particle-emitter - v6.0.0
   * Compiled Mon, 27 May 2024 12:15:21 UTC
   *
   * @barvynkoa/particle-emitter is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
*/
//# sourceMappingURL=@barvynkoa_particle-emitter.js.map
